#include "ns3module.h"
static PyMethodDef spectrum_FatalImpl_functions[] = {
    {NULL, NULL, 0, NULL}
};

static PyObject *
initspectrum_FatalImpl(void)
{
    PyObject *m;
    m = Py_InitModule3((char *) "spectrum.FatalImpl", spectrum_FatalImpl_functions, NULL);
    if (m == NULL) {
        return NULL;
    }
    return m;
}
static PyMethodDef spectrum_addressUtils_functions[] = {
    {NULL, NULL, 0, NULL}
};

static PyObject *
initspectrum_addressUtils(void)
{
    PyObject *m;
    m = Py_InitModule3((char *) "spectrum.addressUtils", spectrum_addressUtils_functions, NULL);
    if (m == NULL) {
        return NULL;
    }
    return m;
}
/* --- module functions --- */


PyObject *
_wrap_spectrum_Log2(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *arg;
    const char *keywords[] = {"arg", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &arg)) {
        return NULL;
    }
    ns3::SpectrumValue retval = ns3::Log2(*((PyNs3SpectrumValue *) arg)->obj);
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(retval);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}
PyObject * _wrap_spectrum_Log2(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_spectrum_Log(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *arg;
    const char *keywords[] = {"arg", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &arg)) {
        return NULL;
    }
    ns3::SpectrumValue retval = ns3::Log(*((PyNs3SpectrumValue *) arg)->obj);
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(retval);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}
PyObject * _wrap_spectrum_Log(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);



PyObject *
_wrap_spectrum_Pow__0(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *lhs;
    double rhs;
    const char *keywords[] = {"lhs", "rhs", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!d", (char **) keywords, &PyNs3SpectrumValue_Type, &lhs, &rhs)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::SpectrumValue retval = ns3::Pow(*((PyNs3SpectrumValue *) lhs)->obj, rhs);
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(retval);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

PyObject *
_wrap_spectrum_Pow__1(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double lhs;
    PyNs3SpectrumValue *rhs;
    const char *keywords[] = {"lhs", "rhs", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dO!", (char **) keywords, &lhs, &PyNs3SpectrumValue_Type, &rhs)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::SpectrumValue retval = ns3::Pow(lhs, *((PyNs3SpectrumValue *) rhs)->obj);
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(retval);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

PyObject * _wrap_spectrum_Pow(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_spectrum_Pow__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_spectrum_Pow__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}
PyObject * _wrap_spectrum_Pow(PyObject *self, PyObject *args, PyObject *kwargs);


PyObject *
_wrap_spectrum_Sum(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyNs3SpectrumValue *x;
    const char *keywords[] = {"x", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &x)) {
        return NULL;
    }
    retval = ns3::Sum(*((PyNs3SpectrumValue *) x)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}
PyObject * _wrap_spectrum_Sum(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_spectrum_Integral(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyNs3SpectrumValue *arg;
    const char *keywords[] = {"arg", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &arg)) {
        return NULL;
    }
    retval = ns3::Integral(*((PyNs3SpectrumValue *) arg)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}
PyObject * _wrap_spectrum_Integral(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_spectrum_Prod(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyNs3SpectrumValue *x;
    const char *keywords[] = {"x", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &x)) {
        return NULL;
    }
    retval = ns3::Prod(*((PyNs3SpectrumValue *) x)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}
PyObject * _wrap_spectrum_Prod(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_spectrum_Log10(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *arg;
    const char *keywords[] = {"arg", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &arg)) {
        return NULL;
    }
    ns3::SpectrumValue retval = ns3::Log10(*((PyNs3SpectrumValue *) arg)->obj);
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(retval);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}
PyObject * _wrap_spectrum_Log10(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_spectrum_Norm(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyNs3SpectrumValue *x;
    const char *keywords[] = {"x", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &x)) {
        return NULL;
    }
    retval = ns3::Norm(*((PyNs3SpectrumValue *) x)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}
PyObject * _wrap_spectrum_Norm(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);

static PyMethodDef spectrum_functions[] = {
    {(char *) "Log2", (PyCFunction) _wrap_spectrum_Log2, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Log", (PyCFunction) _wrap_spectrum_Log, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Pow", (PyCFunction) _wrap_spectrum_Pow, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Sum", (PyCFunction) _wrap_spectrum_Sum, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Integral", (PyCFunction) _wrap_spectrum_Integral, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Prod", (PyCFunction) _wrap_spectrum_Prod, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Log10", (PyCFunction) _wrap_spectrum_Log10, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Norm", (PyCFunction) _wrap_spectrum_Norm, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */


PyTypeObject *_PyNs3Address_Type;
std::map<void*, PyObject*> *_PyNs3Address_wrapper_registry;


PyTypeObject *_PyNs3AttributeConstructionList_Type;
std::map<void*, PyObject*> *_PyNs3AttributeConstructionList_wrapper_registry;


PyTypeObject *_PyNs3AttributeConstructionListItem_Type;
std::map<void*, PyObject*> *_PyNs3AttributeConstructionListItem_wrapper_registry;


PyTypeObject *_PyNs3Buffer_Type;
std::map<void*, PyObject*> *_PyNs3Buffer_wrapper_registry;


PyTypeObject *_PyNs3BufferIterator_Type;
std::map<void*, PyObject*> *_PyNs3BufferIterator_wrapper_registry;


PyTypeObject *_PyNs3ByteTagIterator_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagIterator_wrapper_registry;


PyTypeObject *_PyNs3ByteTagIteratorItem_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagIteratorItem_wrapper_registry;


PyTypeObject *_PyNs3ByteTagList_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagList_wrapper_registry;


PyTypeObject *_PyNs3ByteTagListIterator_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagListIterator_wrapper_registry;


PyTypeObject *_PyNs3ByteTagListIteratorItem_Type;
std::map<void*, PyObject*> *_PyNs3ByteTagListIteratorItem_wrapper_registry;


PyTypeObject *_PyNs3CallbackBase_Type;
std::map<void*, PyObject*> *_PyNs3CallbackBase_wrapper_registry;


PyTypeObject *_PyNs3DataRate_Type;
std::map<void*, PyObject*> *_PyNs3DataRate_wrapper_registry;


PyTypeObject *_PyNs3EventId_Type;
std::map<void*, PyObject*> *_PyNs3EventId_wrapper_registry;


PyTypeObject *_PyNs3Ipv4Address_Type;
std::map<void*, PyObject*> *_PyNs3Ipv4Address_wrapper_registry;


PyTypeObject *_PyNs3Ipv4Mask_Type;
std::map<void*, PyObject*> *_PyNs3Ipv4Mask_wrapper_registry;


PyTypeObject *_PyNs3Ipv6Address_Type;
std::map<void*, PyObject*> *_PyNs3Ipv6Address_wrapper_registry;


PyTypeObject *_PyNs3Ipv6Prefix_Type;
std::map<void*, PyObject*> *_PyNs3Ipv6Prefix_wrapper_registry;


PyTypeObject *_PyNs3Mac48Address_Type;
std::map<void*, PyObject*> *_PyNs3Mac48Address_wrapper_registry;


PyTypeObject *_PyNs3NetDeviceContainer_Type;
std::map<void*, PyObject*> *_PyNs3NetDeviceContainer_wrapper_registry;


PyTypeObject *_PyNs3NodeContainer_Type;
std::map<void*, PyObject*> *_PyNs3NodeContainer_wrapper_registry;


PyTypeObject *_PyNs3ObjectBase_Type;
std::map<void*, PyObject*> *_PyNs3ObjectBase_wrapper_registry;


PyTypeObject *_PyNs3ObjectDeleter_Type;
std::map<void*, PyObject*> *_PyNs3ObjectDeleter_wrapper_registry;


PyTypeObject *_PyNs3ObjectFactory_Type;
std::map<void*, PyObject*> *_PyNs3ObjectFactory_wrapper_registry;


PyTypeObject *_PyNs3PacketMetadata_Type;
std::map<void*, PyObject*> *_PyNs3PacketMetadata_wrapper_registry;


PyTypeObject *_PyNs3PacketMetadataItem_Type;
std::map<void*, PyObject*> *_PyNs3PacketMetadataItem_wrapper_registry;


PyTypeObject *_PyNs3PacketMetadataItemIterator_Type;
std::map<void*, PyObject*> *_PyNs3PacketMetadataItemIterator_wrapper_registry;


PyTypeObject *_PyNs3PacketTagIterator_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagIterator_wrapper_registry;


PyTypeObject *_PyNs3PacketTagIteratorItem_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagIteratorItem_wrapper_registry;


PyTypeObject *_PyNs3PacketTagList_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagList_wrapper_registry;


PyTypeObject *_PyNs3PacketTagListTagData_Type;
std::map<void*, PyObject*> *_PyNs3PacketTagListTagData_wrapper_registry;


PyTypeObject *_PyNs3RandomVariable_Type;
std::map<void*, PyObject*> *_PyNs3RandomVariable_wrapper_registry;


PyTypeObject *_PyNs3SeedManager_Type;
std::map<void*, PyObject*> *_PyNs3SeedManager_wrapper_registry;


PyTypeObject *_PyNs3SequentialVariable_Type;


PyTypeObject *_PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map;


PyTypeObject *_PyNs3SystemWallClockMs_Type;
std::map<void*, PyObject*> *_PyNs3SystemWallClockMs_wrapper_registry;


PyTypeObject *_PyNs3Tag_Type;


PyTypeObject *_PyNs3TagBuffer_Type;
std::map<void*, PyObject*> *_PyNs3TagBuffer_wrapper_registry;


PyTypeObject *_PyNs3TriangularVariable_Type;


PyTypeObject *_PyNs3TypeId_Type;
std::map<void*, PyObject*> *_PyNs3TypeId_wrapper_registry;


PyTypeObject *_PyNs3TypeIdAttributeInformation_Type;
std::map<void*, PyObject*> *_PyNs3TypeIdAttributeInformation_wrapper_registry;


PyTypeObject *_PyNs3TypeIdTraceSourceInformation_Type;
std::map<void*, PyObject*> *_PyNs3TypeIdTraceSourceInformation_wrapper_registry;


PyTypeObject *_PyNs3UniformVariable_Type;


PyTypeObject *_PyNs3Vector2D_Type;
std::map<void*, PyObject*> *_PyNs3Vector2D_wrapper_registry;


PyTypeObject *_PyNs3Vector3D_Type;
std::map<void*, PyObject*> *_PyNs3Vector3D_wrapper_registry;


PyTypeObject *_PyNs3WeibullVariable_Type;


PyTypeObject *_PyNs3ZetaVariable_Type;


PyTypeObject *_PyNs3ZipfVariable_Type;


PyTypeObject *_PyNs3Empty_Type;
std::map<void*, PyObject*> *_PyNs3Empty_wrapper_registry;


PyTypeObject *_PyNs3Int64x64_t_Type;
std::map<void*, PyObject*> *_PyNs3Int64x64_t_wrapper_registry;


PyTypeObject *_PyNs3Chunk_Type;


PyTypeObject *_PyNs3ConstantVariable_Type;


PyTypeObject *_PyNs3DeterministicVariable_Type;


PyTypeObject *_PyNs3EmpiricalVariable_Type;


PyTypeObject *_PyNs3ErlangVariable_Type;


PyTypeObject *_PyNs3ExponentialVariable_Type;


PyTypeObject *_PyNs3GammaVariable_Type;


PyTypeObject *_PyNs3Header_Type;


PyTypeObject *_PyNs3IntEmpiricalVariable_Type;


PyTypeObject *_PyNs3LogNormalVariable_Type;


PyTypeObject *_PyNs3NormalVariable_Type;


PyTypeObject *_PyNs3Object_Type;


PyTypeObject *_PyNs3ObjectAggregateIterator_Type;
std::map<void*, PyObject*> *_PyNs3ObjectAggregateIterator_wrapper_registry;


PyTypeObject *_PyNs3ParetoVariable_Type;


PyTypeObject *_PyNs3PropagationDelayModel_Type;


PyTypeObject *_PyNs3PropagationLossModel_Type;


PyTypeObject *_PyNs3Queue_Type;


PyTypeObject *_PyNs3RandomPropagationDelayModel_Type;


PyTypeObject *_PyNs3RandomPropagationLossModel_Type;


PyTypeObject *_PyNs3RangePropagationLossModel_Type;


PyTypeObject *_PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map;


PyTypeObject *_PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___Type;
pybindgen::TypeMap *_PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map;


PyTypeObject *_PyNs3ThreeLogDistancePropagationLossModel_Type;


PyTypeObject *_PyNs3Time_Type;
std::map<void*, PyObject*> *_PyNs3Time_wrapper_registry;


PyTypeObject *_PyNs3TraceSourceAccessor_Type;


PyTypeObject *_PyNs3Trailer_Type;


PyTypeObject *_PyNs3TwoRayGroundPropagationLossModel_Type;


PyTypeObject *_PyNs3AttributeAccessor_Type;


PyTypeObject *_PyNs3AttributeChecker_Type;


PyTypeObject *_PyNs3AttributeValue_Type;


PyTypeObject *_PyNs3CallbackChecker_Type;


PyTypeObject *_PyNs3CallbackImplBase_Type;


PyTypeObject *_PyNs3CallbackValue_Type;


PyTypeObject *_PyNs3Channel_Type;


PyTypeObject *_PyNs3ConstantSpeedPropagationDelayModel_Type;


PyTypeObject *_PyNs3DataRateChecker_Type;


PyTypeObject *_PyNs3DataRateValue_Type;


PyTypeObject *_PyNs3EmptyAttributeValue_Type;


PyTypeObject *_PyNs3EventImpl_Type;


PyTypeObject *_PyNs3FixedRssLossModel_Type;


PyTypeObject *_PyNs3FriisPropagationLossModel_Type;


PyTypeObject *_PyNs3Ipv4AddressChecker_Type;


PyTypeObject *_PyNs3Ipv4AddressValue_Type;


PyTypeObject *_PyNs3Ipv4MaskChecker_Type;


PyTypeObject *_PyNs3Ipv4MaskValue_Type;


PyTypeObject *_PyNs3Ipv6AddressChecker_Type;


PyTypeObject *_PyNs3Ipv6AddressValue_Type;


PyTypeObject *_PyNs3Ipv6PrefixChecker_Type;


PyTypeObject *_PyNs3Ipv6PrefixValue_Type;


PyTypeObject *_PyNs3LogDistancePropagationLossModel_Type;


PyTypeObject *_PyNs3Mac48AddressChecker_Type;


PyTypeObject *_PyNs3Mac48AddressValue_Type;


PyTypeObject *_PyNs3MatrixPropagationLossModel_Type;


PyTypeObject *_PyNs3MobilityModel_Type;


PyTypeObject *_PyNs3NakagamiPropagationLossModel_Type;


PyTypeObject *_PyNs3NetDevice_Type;


PyTypeObject *_PyNs3NixVector_Type;


PyTypeObject *_PyNs3Node_Type;


PyTypeObject *_PyNs3ObjectFactoryChecker_Type;


PyTypeObject *_PyNs3ObjectFactoryValue_Type;


PyTypeObject *_PyNs3Packet_Type;


PyTypeObject *_PyNs3RandomVariableChecker_Type;


PyTypeObject *_PyNs3RandomVariableValue_Type;


PyTypeObject *_PyNs3TimeChecker_Type;


PyTypeObject *_PyNs3TimeValue_Type;


PyTypeObject *_PyNs3TypeIdChecker_Type;


PyTypeObject *_PyNs3TypeIdValue_Type;


PyTypeObject *_PyNs3Vector2DChecker_Type;


PyTypeObject *_PyNs3Vector2DValue_Type;


PyTypeObject *_PyNs3Vector3DChecker_Type;


PyTypeObject *_PyNs3Vector3DValue_Type;


PyTypeObject *_PyNs3AddressChecker_Type;


PyTypeObject *_PyNs3AddressValue_Type;


std::map<void*, PyObject*> PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry;


static int
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_init__0(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3AdhocAlohaNoackIdealPhyHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3AdhocAlohaNoackIdealPhyHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::AdhocAlohaNoackIdealPhyHelper(*((PyNs3AdhocAlohaNoackIdealPhyHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_init__1(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::AdhocAlohaNoackIdealPhyHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_init(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetPhyAttribute(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *v;
    const char *keywords[] = {"name", "v", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &v)) {
        return NULL;
    }
    self->obj->SetPhyAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) v)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetDeviceAttribute(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *n1;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1;
    const char *keywords[] = {"n1", "v1", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1)) {
        return NULL;
    }
    self->obj->SetDeviceAttribute(std::string(n1, n1_len), *((PyNs3AttributeValue *) v1)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetChannel__0(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *channel;
    ns3::SpectrumChannel *channel_ptr;
    const char *keywords[] = {"channel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &channel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    channel_ptr = (channel ? channel->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (channel_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetChannel__1(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *channelName;
    Py_ssize_t channelName_len;
    const char *keywords[] = {"channelName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &channelName, &channelName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetChannel(std::string(channelName, channelName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetChannel(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetChannel__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetChannel__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetTxPowerSpectralDensity(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *txPsd;
    ns3::SpectrumValue *txPsd_ptr;
    const char *keywords[] = {"txPsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txPsd)) {
        return NULL;
    }
    txPsd_ptr = (txPsd ? txPsd->obj : NULL);
    self->obj->SetTxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (txPsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install__0(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3NodeContainer *c;
    const char *keywords[] = {"c", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NodeContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::NetDeviceContainer retval = self->obj->Install(*((PyNs3NodeContainer *) c)->obj);
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install__1(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    ns3::NetDeviceContainer retval = self->obj->Install(ns3::Ptr< ns3::Node  > (node_ptr));
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install__2(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nodeName;
    Py_ssize_t nodeName_len;
    const char *keywords[] = {"nodeName", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &nodeName, &nodeName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::NetDeviceContainer retval = self->obj->Install(std::string(nodeName, nodeName_len));
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject * _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetNoisePowerSpectralDensity(PyNs3AdhocAlohaNoackIdealPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *noisePsd;
    ns3::SpectrumValue *noisePsd_ptr;
    const char *keywords[] = {"noisePsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &noisePsd)) {
        return NULL;
    }
    noisePsd_ptr = (noisePsd ? noisePsd->obj : NULL);
    self->obj->SetNoisePowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (noisePsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__copy__(PyNs3AdhocAlohaNoackIdealPhyHelper *self)
{

    PyNs3AdhocAlohaNoackIdealPhyHelper *py_copy;
    py_copy = PyObject_New(PyNs3AdhocAlohaNoackIdealPhyHelper, &PyNs3AdhocAlohaNoackIdealPhyHelper_Type);
    py_copy->obj = new ns3::AdhocAlohaNoackIdealPhyHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3AdhocAlohaNoackIdealPhyHelper_methods[] = {
    {(char *) "SetPhyAttribute", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetPhyAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDeviceAttribute", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetDeviceAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetTxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Install", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_Install, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNoisePowerSpectralDensity", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper_SetNoisePowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_dealloc(PyNs3AdhocAlohaNoackIdealPhyHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry.end()) {
        PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::AdhocAlohaNoackIdealPhyHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_richcompare (PyNs3AdhocAlohaNoackIdealPhyHelper *PYBINDGEN_UNUSED(self), PyNs3AdhocAlohaNoackIdealPhyHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3AdhocAlohaNoackIdealPhyHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3AdhocAlohaNoackIdealPhyHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.AdhocAlohaNoackIdealPhyHelper",            /* tp_name */
    sizeof(PyNs3AdhocAlohaNoackIdealPhyHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3AdhocAlohaNoackIdealPhyHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3AdhocAlohaNoackIdealPhyHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3BandInfo_wrapper_registry;
static PyObject* _wrap_PyNs3BandInfo__get_fc(PyNs3BandInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "d", self->obj->fc);
    return py_retval;
}
static int _wrap_PyNs3BandInfo__set_fc(PyNs3BandInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "d", &self->obj->fc)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3BandInfo__get_fh(PyNs3BandInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "d", self->obj->fh);
    return py_retval;
}
static int _wrap_PyNs3BandInfo__set_fh(PyNs3BandInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "d", &self->obj->fh)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3BandInfo__get_fl(PyNs3BandInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "d", self->obj->fl);
    return py_retval;
}
static int _wrap_PyNs3BandInfo__set_fl(PyNs3BandInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "d", &self->obj->fl)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3BandInfo__getsets[] = {
    {
        (char*) "fh", /* attribute name */
        (getter) _wrap_PyNs3BandInfo__get_fh, /* C function to get the attribute */
        (setter) _wrap_PyNs3BandInfo__set_fh, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "fc", /* attribute name */
        (getter) _wrap_PyNs3BandInfo__get_fc, /* C function to get the attribute */
        (setter) _wrap_PyNs3BandInfo__set_fc, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "fl", /* attribute name */
        (getter) _wrap_PyNs3BandInfo__get_fl, /* C function to get the attribute */
        (setter) _wrap_PyNs3BandInfo__set_fl, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3BandInfo__tp_init__0(PyNs3BandInfo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::BandInfo();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3BandInfo__tp_init__1(PyNs3BandInfo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3BandInfo *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BandInfo_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::BandInfo(*((PyNs3BandInfo *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3BandInfo__tp_init(PyNs3BandInfo *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3BandInfo__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3BandInfo__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyNs3BandInfo__copy__(PyNs3BandInfo *self)
{

    PyNs3BandInfo *py_copy;
    py_copy = PyObject_New(PyNs3BandInfo, &PyNs3BandInfo_Type);
    py_copy->obj = new ns3::BandInfo(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3BandInfo_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3BandInfo_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3BandInfo__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3BandInfo__tp_dealloc(PyNs3BandInfo *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3BandInfo_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3BandInfo_wrapper_registry.end()) {
        PyNs3BandInfo_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::BandInfo *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3BandInfo__tp_richcompare (PyNs3BandInfo *PYBINDGEN_UNUSED(self), PyNs3BandInfo *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3BandInfo_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3BandInfo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.BandInfo",            /* tp_name */
    sizeof(PyNs3BandInfo),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3BandInfo__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3BandInfo__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3BandInfo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3BandInfo__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3BandInfo__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry;


static int
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_init__0(PyNs3MicrowaveOvenSpectrumValueHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::MicrowaveOvenSpectrumValueHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_init__1(PyNs3MicrowaveOvenSpectrumValueHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3MicrowaveOvenSpectrumValueHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MicrowaveOvenSpectrumValueHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::MicrowaveOvenSpectrumValueHelper(*((PyNs3MicrowaveOvenSpectrumValueHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_init(PyNs3MicrowaveOvenSpectrumValueHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper_CreatePowerSpectralDensityMwo2(void)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = ns3::MicrowaveOvenSpectrumValueHelper::CreatePowerSpectralDensityMwo2();
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper_CreatePowerSpectralDensityMwo1(void)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = ns3::MicrowaveOvenSpectrumValueHelper::CreatePowerSpectralDensityMwo1();
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


static PyObject*
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__copy__(PyNs3MicrowaveOvenSpectrumValueHelper *self)
{

    PyNs3MicrowaveOvenSpectrumValueHelper *py_copy;
    py_copy = PyObject_New(PyNs3MicrowaveOvenSpectrumValueHelper, &PyNs3MicrowaveOvenSpectrumValueHelper_Type);
    py_copy->obj = new ns3::MicrowaveOvenSpectrumValueHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3MicrowaveOvenSpectrumValueHelper_methods[] = {
    {(char *) "CreatePowerSpectralDensityMwo2", (PyCFunction) _wrap_PyNs3MicrowaveOvenSpectrumValueHelper_CreatePowerSpectralDensityMwo2, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "CreatePowerSpectralDensityMwo1", (PyCFunction) _wrap_PyNs3MicrowaveOvenSpectrumValueHelper_CreatePowerSpectralDensityMwo1, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3MicrowaveOvenSpectrumValueHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_dealloc(PyNs3MicrowaveOvenSpectrumValueHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry.end()) {
        PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::MicrowaveOvenSpectrumValueHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_richcompare (PyNs3MicrowaveOvenSpectrumValueHelper *PYBINDGEN_UNUSED(self), PyNs3MicrowaveOvenSpectrumValueHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3MicrowaveOvenSpectrumValueHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3MicrowaveOvenSpectrumValueHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.MicrowaveOvenSpectrumValueHelper",            /* tp_name */
    sizeof(PyNs3MicrowaveOvenSpectrumValueHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3MicrowaveOvenSpectrumValueHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3MicrowaveOvenSpectrumValueHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3RxSpectrumModelInfo_wrapper_registry;
static PyObject* _wrap_PyNs3RxSpectrumModelInfo__get_m_rxPhyList(PyNs3RxSpectrumModelInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *py_std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__;
    
    py_std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ = PyObject_New(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__, &Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type);
    py_std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__->obj = new std::list< ns3::Ptr< ns3::SpectrumPhy > >(self->obj->m_rxPhyList);
    py_retval = Py_BuildValue((char *) "N", py_std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__);
    return py_retval;
}
static int _wrap_PyNs3RxSpectrumModelInfo__set_m_rxPhyList(PyNs3RxSpectrumModelInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O&", _wrap_convert_py2c__std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__, &self->obj->m_rxPhyList)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3RxSpectrumModelInfo__get_m_rxSpectrumModel(PyNs3RxSpectrumModelInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_rxSpectrumModel)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_rxSpectrumModel)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_rxSpectrumModel)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_rxSpectrumModel))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_rxSpectrumModel));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}
static int _wrap_PyNs3RxSpectrumModelInfo__set_m_rxSpectrumModel(PyNs3RxSpectrumModelInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumModel *tmp_SpectrumModel;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumModel_Type, &tmp_SpectrumModel)) {
        Py_DECREF(py_retval);
        return -1;
    }
    // dangerous!
    self->obj->m_rxSpectrumModel = ns3::Ptr< ns3::SpectrumModel  > (tmp_SpectrumModel->obj);
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3RxSpectrumModelInfo__getsets[] = {
    {
        (char*) "m_rxPhyList", /* attribute name */
        (getter) _wrap_PyNs3RxSpectrumModelInfo__get_m_rxPhyList, /* C function to get the attribute */
        (setter) _wrap_PyNs3RxSpectrumModelInfo__set_m_rxPhyList, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "m_rxSpectrumModel", /* attribute name */
        (getter) _wrap_PyNs3RxSpectrumModelInfo__get_m_rxSpectrumModel, /* C function to get the attribute */
        (setter) _wrap_PyNs3RxSpectrumModelInfo__set_m_rxSpectrumModel, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3RxSpectrumModelInfo__tp_init__0(PyNs3RxSpectrumModelInfo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3RxSpectrumModelInfo *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3RxSpectrumModelInfo_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::RxSpectrumModelInfo(*((PyNs3RxSpectrumModelInfo *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3RxSpectrumModelInfo__tp_init__1(PyNs3RxSpectrumModelInfo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumModel *rxSpectrumModel;
    ns3::SpectrumModel *rxSpectrumModel_ptr;
    const char *keywords[] = {"rxSpectrumModel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumModel_Type, &rxSpectrumModel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    rxSpectrumModel_ptr = (rxSpectrumModel ? rxSpectrumModel->obj : NULL);
    self->obj = new ns3::RxSpectrumModelInfo(ns3::Ptr< ns3::SpectrumModel  > (rxSpectrumModel_ptr));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3RxSpectrumModelInfo__tp_init(PyNs3RxSpectrumModelInfo *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3RxSpectrumModelInfo__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3RxSpectrumModelInfo__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyNs3RxSpectrumModelInfo__copy__(PyNs3RxSpectrumModelInfo *self)
{

    PyNs3RxSpectrumModelInfo *py_copy;
    py_copy = PyObject_New(PyNs3RxSpectrumModelInfo, &PyNs3RxSpectrumModelInfo_Type);
    py_copy->obj = new ns3::RxSpectrumModelInfo(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3RxSpectrumModelInfo_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3RxSpectrumModelInfo_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3RxSpectrumModelInfo__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3RxSpectrumModelInfo__tp_dealloc(PyNs3RxSpectrumModelInfo *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3RxSpectrumModelInfo_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3RxSpectrumModelInfo_wrapper_registry.end()) {
        PyNs3RxSpectrumModelInfo_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::RxSpectrumModelInfo *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3RxSpectrumModelInfo__tp_richcompare (PyNs3RxSpectrumModelInfo *PYBINDGEN_UNUSED(self), PyNs3RxSpectrumModelInfo *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3RxSpectrumModelInfo_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3RxSpectrumModelInfo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.RxSpectrumModelInfo",            /* tp_name */
    sizeof(PyNs3RxSpectrumModelInfo),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3RxSpectrumModelInfo__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3RxSpectrumModelInfo__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3RxSpectrumModelInfo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3RxSpectrumModelInfo__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3RxSpectrumModelInfo__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3SpectrumAnalyzerHelper_wrapper_registry;


static int
_wrap_PyNs3SpectrumAnalyzerHelper__tp_init__0(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumAnalyzerHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumAnalyzerHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumAnalyzerHelper(*((PyNs3SpectrumAnalyzerHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumAnalyzerHelper__tp_init__1(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumAnalyzerHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumAnalyzerHelper__tp_init(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumAnalyzerHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumAnalyzerHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_EnableAsciiAll(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *prefix;
    Py_ssize_t prefix_len;
    const char *keywords[] = {"prefix", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &prefix, &prefix_len)) {
        return NULL;
    }
    self->obj->EnableAsciiAll(std::string(prefix, prefix_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_SetPhyAttribute(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *v;
    const char *keywords[] = {"name", "v", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &v)) {
        return NULL;
    }
    self->obj->SetPhyAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) v)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_SetDeviceAttribute(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *n1;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1;
    const char *keywords[] = {"n1", "v1", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1)) {
        return NULL;
    }
    self->obj->SetDeviceAttribute(std::string(n1, n1_len), *((PyNs3AttributeValue *) v1)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_SetChannel__0(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *channel;
    ns3::SpectrumChannel *channel_ptr;
    const char *keywords[] = {"channel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &channel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    channel_ptr = (channel ? channel->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (channel_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_SetChannel__1(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *channelName;
    Py_ssize_t channelName_len;
    const char *keywords[] = {"channelName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &channelName, &channelName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetChannel(std::string(channelName, channelName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3SpectrumAnalyzerHelper_SetChannel(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumAnalyzerHelper_SetChannel__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumAnalyzerHelper_SetChannel__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}



PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_Install__0(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3NodeContainer *c;
    const char *keywords[] = {"c", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NodeContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::NetDeviceContainer retval = self->obj->Install(*((PyNs3NodeContainer *) c)->obj);
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_Install__1(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    ns3::NetDeviceContainer retval = self->obj->Install(ns3::Ptr< ns3::Node  > (node_ptr));
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_Install__2(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nodeName;
    Py_ssize_t nodeName_len;
    const char *keywords[] = {"nodeName", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &nodeName, &nodeName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::NetDeviceContainer retval = self->obj->Install(std::string(nodeName, nodeName_len));
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject * _wrap_PyNs3SpectrumAnalyzerHelper_Install(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3SpectrumAnalyzerHelper_Install__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumAnalyzerHelper_Install__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3SpectrumAnalyzerHelper_Install__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzerHelper_SetRxSpectrumModel(PyNs3SpectrumAnalyzerHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumModel *m;
    ns3::SpectrumModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->SetRxSpectrumModel(ns3::Ptr< ns3::SpectrumModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumAnalyzerHelper__copy__(PyNs3SpectrumAnalyzerHelper *self)
{

    PyNs3SpectrumAnalyzerHelper *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumAnalyzerHelper, &PyNs3SpectrumAnalyzerHelper_Type);
    py_copy->obj = new ns3::SpectrumAnalyzerHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3SpectrumAnalyzerHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumAnalyzerHelper_methods[] = {
    {(char *) "EnableAsciiAll", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper_EnableAsciiAll, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPhyAttribute", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper_SetPhyAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDeviceAttribute", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper_SetDeviceAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Install", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper_Install, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetRxSpectrumModel", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper_SetRxSpectrumModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumAnalyzerHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumAnalyzerHelper__tp_dealloc(PyNs3SpectrumAnalyzerHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3SpectrumAnalyzerHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3SpectrumAnalyzerHelper_wrapper_registry.end()) {
        PyNs3SpectrumAnalyzerHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::SpectrumAnalyzerHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumAnalyzerHelper__tp_richcompare (PyNs3SpectrumAnalyzerHelper *PYBINDGEN_UNUSED(self), PyNs3SpectrumAnalyzerHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumAnalyzerHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumAnalyzerHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumAnalyzerHelper",            /* tp_name */
    sizeof(PyNs3SpectrumAnalyzerHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumAnalyzerHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumAnalyzerHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumAnalyzerHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumAnalyzerHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3SpectrumChannelHelper_wrapper_registry;


static int
_wrap_PyNs3SpectrumChannelHelper__tp_init__0(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumChannelHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumChannelHelper__tp_init__1(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumChannelHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannelHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumChannelHelper(*((PyNs3SpectrumChannelHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumChannelHelper__tp_init(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumChannelHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumChannelHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3SpectrumChannelHelper_AddSpectrumPropagationLoss__0(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    const char *n0 = NULL;
    Py_ssize_t n0_len;
    PyNs3AttributeValue *v0 = NULL;
    ns3::EmptyAttributeValue v0_default = ns3::EmptyAttributeValue();
    const char *n1 = NULL;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1 = NULL;
    ns3::EmptyAttributeValue v1_default = ns3::EmptyAttributeValue();
    const char *n2 = NULL;
    Py_ssize_t n2_len;
    PyNs3AttributeValue *v2 = NULL;
    ns3::EmptyAttributeValue v2_default = ns3::EmptyAttributeValue();
    const char *n3 = NULL;
    Py_ssize_t n3_len;
    PyNs3AttributeValue *v3 = NULL;
    ns3::EmptyAttributeValue v3_default = ns3::EmptyAttributeValue();
    const char *n4 = NULL;
    Py_ssize_t n4_len;
    PyNs3AttributeValue *v4 = NULL;
    ns3::EmptyAttributeValue v4_default = ns3::EmptyAttributeValue();
    const char *n5 = NULL;
    Py_ssize_t n5_len;
    PyNs3AttributeValue *v5 = NULL;
    ns3::EmptyAttributeValue v5_default = ns3::EmptyAttributeValue();
    const char *n6 = NULL;
    Py_ssize_t n6_len;
    PyNs3AttributeValue *v6 = NULL;
    ns3::EmptyAttributeValue v6_default = ns3::EmptyAttributeValue();
    const char *n7 = NULL;
    Py_ssize_t n7_len;
    PyNs3AttributeValue *v7 = NULL;
    ns3::EmptyAttributeValue v7_default = ns3::EmptyAttributeValue();
    const char *keywords[] = {"name", "n0", "v0", "n1", "v1", "n2", "v2", "n3", "v3", "n4", "v4", "n5", "v5", "n6", "v6", "n7", "v7", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#O!s#O!s#O!s#O!s#O!s#O!s#O!s#O!", (char **) keywords, &name, &name_len, &n0, &n0_len, &PyNs3AttributeValue_Type, &v0, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1, &n2, &n2_len, &PyNs3AttributeValue_Type, &v2, &n3, &n3_len, &PyNs3AttributeValue_Type, &v3, &n4, &n4_len, &PyNs3AttributeValue_Type, &v4, &n5, &n5_len, &PyNs3AttributeValue_Type, &v5, &n6, &n6_len, &PyNs3AttributeValue_Type, &v6, &n7, &n7_len, &PyNs3AttributeValue_Type, &v7)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddSpectrumPropagationLoss(std::string(name, name_len), (n0 ? std::string(n0, n0_len) : ""), (v0 ? (*((PyNs3AttributeValue *) v0)->obj) : v0_default), (n1 ? std::string(n1, n1_len) : ""), (v1 ? (*((PyNs3AttributeValue *) v1)->obj) : v1_default), (n2 ? std::string(n2, n2_len) : ""), (v2 ? (*((PyNs3AttributeValue *) v2)->obj) : v2_default), (n3 ? std::string(n3, n3_len) : ""), (v3 ? (*((PyNs3AttributeValue *) v3)->obj) : v3_default), (n4 ? std::string(n4, n4_len) : ""), (v4 ? (*((PyNs3AttributeValue *) v4)->obj) : v4_default), (n5 ? std::string(n5, n5_len) : ""), (v5 ? (*((PyNs3AttributeValue *) v5)->obj) : v5_default), (n6 ? std::string(n6, n6_len) : ""), (v6 ? (*((PyNs3AttributeValue *) v6)->obj) : v6_default), (n7 ? std::string(n7, n7_len) : ""), (v7 ? (*((PyNs3AttributeValue *) v7)->obj) : v7_default));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3SpectrumChannelHelper_AddSpectrumPropagationLoss__1(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *m;
    ns3::SpectrumPropagationLossModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &m)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->AddSpectrumPropagationLoss(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3SpectrumChannelHelper_AddSpectrumPropagationLoss(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumChannelHelper_AddSpectrumPropagationLoss__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumChannelHelper_AddSpectrumPropagationLoss__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3SpectrumChannelHelper_Default(void)
{
    PyObject *py_retval;
    PyNs3SpectrumChannelHelper *py_SpectrumChannelHelper;
    
    ns3::SpectrumChannelHelper retval = ns3::SpectrumChannelHelper::Default();
    py_SpectrumChannelHelper = PyObject_New(PyNs3SpectrumChannelHelper, &PyNs3SpectrumChannelHelper_Type);
    py_SpectrumChannelHelper->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumChannelHelper->obj = new ns3::SpectrumChannelHelper(retval);
    PyNs3SpectrumChannelHelper_wrapper_registry[(void *) py_SpectrumChannelHelper->obj] = (PyObject *) py_SpectrumChannelHelper;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumChannelHelper);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannelHelper_Create(PyNs3SpectrumChannelHelper *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumChannel > retval;
    PyNs3SpectrumChannel *py_SpectrumChannel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->Create();
    if (!(const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3SpectrumChannel__PythonHelper).name())
    {
        py_SpectrumChannel = reinterpret_cast< PyNs3SpectrumChannel* >(reinterpret_cast< PyNs3SpectrumChannel__PythonHelper* >(const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_SpectrumChannel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumChannel = NULL;
        } else {
            py_SpectrumChannel = (PyNs3SpectrumChannel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumChannel);
        }
    
        if (py_SpectrumChannel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumChannel_Type);
            py_SpectrumChannel = PyObject_GC_New(PyNs3SpectrumChannel, wrapper_type);
            py_SpectrumChannel->inst_dict = NULL;
            py_SpectrumChannel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval))->Ref();
            py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumChannel->obj] = (PyObject *) py_SpectrumChannel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumChannel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannelHelper_SetPropagationDelay(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    const char *n0 = NULL;
    Py_ssize_t n0_len;
    PyNs3AttributeValue *v0 = NULL;
    ns3::EmptyAttributeValue v0_default = ns3::EmptyAttributeValue();
    const char *n1 = NULL;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1 = NULL;
    ns3::EmptyAttributeValue v1_default = ns3::EmptyAttributeValue();
    const char *n2 = NULL;
    Py_ssize_t n2_len;
    PyNs3AttributeValue *v2 = NULL;
    ns3::EmptyAttributeValue v2_default = ns3::EmptyAttributeValue();
    const char *n3 = NULL;
    Py_ssize_t n3_len;
    PyNs3AttributeValue *v3 = NULL;
    ns3::EmptyAttributeValue v3_default = ns3::EmptyAttributeValue();
    const char *n4 = NULL;
    Py_ssize_t n4_len;
    PyNs3AttributeValue *v4 = NULL;
    ns3::EmptyAttributeValue v4_default = ns3::EmptyAttributeValue();
    const char *n5 = NULL;
    Py_ssize_t n5_len;
    PyNs3AttributeValue *v5 = NULL;
    ns3::EmptyAttributeValue v5_default = ns3::EmptyAttributeValue();
    const char *n6 = NULL;
    Py_ssize_t n6_len;
    PyNs3AttributeValue *v6 = NULL;
    ns3::EmptyAttributeValue v6_default = ns3::EmptyAttributeValue();
    const char *n7 = NULL;
    Py_ssize_t n7_len;
    PyNs3AttributeValue *v7 = NULL;
    ns3::EmptyAttributeValue v7_default = ns3::EmptyAttributeValue();
    const char *keywords[] = {"name", "n0", "v0", "n1", "v1", "n2", "v2", "n3", "v3", "n4", "v4", "n5", "v5", "n6", "v6", "n7", "v7", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#O!s#O!s#O!s#O!s#O!s#O!s#O!s#O!", (char **) keywords, &name, &name_len, &n0, &n0_len, &PyNs3AttributeValue_Type, &v0, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1, &n2, &n2_len, &PyNs3AttributeValue_Type, &v2, &n3, &n3_len, &PyNs3AttributeValue_Type, &v3, &n4, &n4_len, &PyNs3AttributeValue_Type, &v4, &n5, &n5_len, &PyNs3AttributeValue_Type, &v5, &n6, &n6_len, &PyNs3AttributeValue_Type, &v6, &n7, &n7_len, &PyNs3AttributeValue_Type, &v7)) {
        return NULL;
    }
    self->obj->SetPropagationDelay(std::string(name, name_len), (n0 ? std::string(n0, n0_len) : ""), (v0 ? (*((PyNs3AttributeValue *) v0)->obj) : v0_default), (n1 ? std::string(n1, n1_len) : ""), (v1 ? (*((PyNs3AttributeValue *) v1)->obj) : v1_default), (n2 ? std::string(n2, n2_len) : ""), (v2 ? (*((PyNs3AttributeValue *) v2)->obj) : v2_default), (n3 ? std::string(n3, n3_len) : ""), (v3 ? (*((PyNs3AttributeValue *) v3)->obj) : v3_default), (n4 ? std::string(n4, n4_len) : ""), (v4 ? (*((PyNs3AttributeValue *) v4)->obj) : v4_default), (n5 ? std::string(n5, n5_len) : ""), (v5 ? (*((PyNs3AttributeValue *) v5)->obj) : v5_default), (n6 ? std::string(n6, n6_len) : ""), (v6 ? (*((PyNs3AttributeValue *) v6)->obj) : v6_default), (n7 ? std::string(n7, n7_len) : ""), (v7 ? (*((PyNs3AttributeValue *) v7)->obj) : v7_default));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3SpectrumChannelHelper_AddPropagationLoss__0(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    const char *n0 = NULL;
    Py_ssize_t n0_len;
    PyNs3AttributeValue *v0 = NULL;
    ns3::EmptyAttributeValue v0_default = ns3::EmptyAttributeValue();
    const char *n1 = NULL;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1 = NULL;
    ns3::EmptyAttributeValue v1_default = ns3::EmptyAttributeValue();
    const char *n2 = NULL;
    Py_ssize_t n2_len;
    PyNs3AttributeValue *v2 = NULL;
    ns3::EmptyAttributeValue v2_default = ns3::EmptyAttributeValue();
    const char *n3 = NULL;
    Py_ssize_t n3_len;
    PyNs3AttributeValue *v3 = NULL;
    ns3::EmptyAttributeValue v3_default = ns3::EmptyAttributeValue();
    const char *n4 = NULL;
    Py_ssize_t n4_len;
    PyNs3AttributeValue *v4 = NULL;
    ns3::EmptyAttributeValue v4_default = ns3::EmptyAttributeValue();
    const char *n5 = NULL;
    Py_ssize_t n5_len;
    PyNs3AttributeValue *v5 = NULL;
    ns3::EmptyAttributeValue v5_default = ns3::EmptyAttributeValue();
    const char *n6 = NULL;
    Py_ssize_t n6_len;
    PyNs3AttributeValue *v6 = NULL;
    ns3::EmptyAttributeValue v6_default = ns3::EmptyAttributeValue();
    const char *n7 = NULL;
    Py_ssize_t n7_len;
    PyNs3AttributeValue *v7 = NULL;
    ns3::EmptyAttributeValue v7_default = ns3::EmptyAttributeValue();
    const char *keywords[] = {"name", "n0", "v0", "n1", "v1", "n2", "v2", "n3", "v3", "n4", "v4", "n5", "v5", "n6", "v6", "n7", "v7", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#O!s#O!s#O!s#O!s#O!s#O!s#O!s#O!", (char **) keywords, &name, &name_len, &n0, &n0_len, &PyNs3AttributeValue_Type, &v0, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1, &n2, &n2_len, &PyNs3AttributeValue_Type, &v2, &n3, &n3_len, &PyNs3AttributeValue_Type, &v3, &n4, &n4_len, &PyNs3AttributeValue_Type, &v4, &n5, &n5_len, &PyNs3AttributeValue_Type, &v5, &n6, &n6_len, &PyNs3AttributeValue_Type, &v6, &n7, &n7_len, &PyNs3AttributeValue_Type, &v7)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->AddPropagationLoss(std::string(name, name_len), (n0 ? std::string(n0, n0_len) : ""), (v0 ? (*((PyNs3AttributeValue *) v0)->obj) : v0_default), (n1 ? std::string(n1, n1_len) : ""), (v1 ? (*((PyNs3AttributeValue *) v1)->obj) : v1_default), (n2 ? std::string(n2, n2_len) : ""), (v2 ? (*((PyNs3AttributeValue *) v2)->obj) : v2_default), (n3 ? std::string(n3, n3_len) : ""), (v3 ? (*((PyNs3AttributeValue *) v3)->obj) : v3_default), (n4 ? std::string(n4, n4_len) : ""), (v4 ? (*((PyNs3AttributeValue *) v4)->obj) : v4_default), (n5 ? std::string(n5, n5_len) : ""), (v5 ? (*((PyNs3AttributeValue *) v5)->obj) : v5_default), (n6 ? std::string(n6, n6_len) : ""), (v6 ? (*((PyNs3AttributeValue *) v6)->obj) : v6_default), (n7 ? std::string(n7, n7_len) : ""), (v7 ? (*((PyNs3AttributeValue *) v7)->obj) : v7_default));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3SpectrumChannelHelper_AddPropagationLoss__1(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3PropagationLossModel *m;
    ns3::PropagationLossModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationLossModel_Type, &m)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->AddPropagationLoss(ns3::Ptr< ns3::PropagationLossModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3SpectrumChannelHelper_AddPropagationLoss(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumChannelHelper_AddPropagationLoss__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumChannelHelper_AddPropagationLoss__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3SpectrumChannelHelper_SetChannel(PyNs3SpectrumChannelHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *type;
    Py_ssize_t type_len;
    const char *n0 = NULL;
    Py_ssize_t n0_len;
    PyNs3AttributeValue *v0 = NULL;
    ns3::EmptyAttributeValue v0_default = ns3::EmptyAttributeValue();
    const char *n1 = NULL;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1 = NULL;
    ns3::EmptyAttributeValue v1_default = ns3::EmptyAttributeValue();
    const char *n2 = NULL;
    Py_ssize_t n2_len;
    PyNs3AttributeValue *v2 = NULL;
    ns3::EmptyAttributeValue v2_default = ns3::EmptyAttributeValue();
    const char *n3 = NULL;
    Py_ssize_t n3_len;
    PyNs3AttributeValue *v3 = NULL;
    ns3::EmptyAttributeValue v3_default = ns3::EmptyAttributeValue();
    const char *n4 = NULL;
    Py_ssize_t n4_len;
    PyNs3AttributeValue *v4 = NULL;
    ns3::EmptyAttributeValue v4_default = ns3::EmptyAttributeValue();
    const char *n5 = NULL;
    Py_ssize_t n5_len;
    PyNs3AttributeValue *v5 = NULL;
    ns3::EmptyAttributeValue v5_default = ns3::EmptyAttributeValue();
    const char *n6 = NULL;
    Py_ssize_t n6_len;
    PyNs3AttributeValue *v6 = NULL;
    ns3::EmptyAttributeValue v6_default = ns3::EmptyAttributeValue();
    const char *n7 = NULL;
    Py_ssize_t n7_len;
    PyNs3AttributeValue *v7 = NULL;
    ns3::EmptyAttributeValue v7_default = ns3::EmptyAttributeValue();
    const char *keywords[] = {"type", "n0", "v0", "n1", "v1", "n2", "v2", "n3", "v3", "n4", "v4", "n5", "v5", "n6", "v6", "n7", "v7", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#O!s#O!s#O!s#O!s#O!s#O!s#O!s#O!", (char **) keywords, &type, &type_len, &n0, &n0_len, &PyNs3AttributeValue_Type, &v0, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1, &n2, &n2_len, &PyNs3AttributeValue_Type, &v2, &n3, &n3_len, &PyNs3AttributeValue_Type, &v3, &n4, &n4_len, &PyNs3AttributeValue_Type, &v4, &n5, &n5_len, &PyNs3AttributeValue_Type, &v5, &n6, &n6_len, &PyNs3AttributeValue_Type, &v6, &n7, &n7_len, &PyNs3AttributeValue_Type, &v7)) {
        return NULL;
    }
    self->obj->SetChannel(std::string(type, type_len), (n0 ? std::string(n0, n0_len) : ""), (v0 ? (*((PyNs3AttributeValue *) v0)->obj) : v0_default), (n1 ? std::string(n1, n1_len) : ""), (v1 ? (*((PyNs3AttributeValue *) v1)->obj) : v1_default), (n2 ? std::string(n2, n2_len) : ""), (v2 ? (*((PyNs3AttributeValue *) v2)->obj) : v2_default), (n3 ? std::string(n3, n3_len) : ""), (v3 ? (*((PyNs3AttributeValue *) v3)->obj) : v3_default), (n4 ? std::string(n4, n4_len) : ""), (v4 ? (*((PyNs3AttributeValue *) v4)->obj) : v4_default), (n5 ? std::string(n5, n5_len) : ""), (v5 ? (*((PyNs3AttributeValue *) v5)->obj) : v5_default), (n6 ? std::string(n6, n6_len) : ""), (v6 ? (*((PyNs3AttributeValue *) v6)->obj) : v6_default), (n7 ? std::string(n7, n7_len) : ""), (v7 ? (*((PyNs3AttributeValue *) v7)->obj) : v7_default));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumChannelHelper__copy__(PyNs3SpectrumChannelHelper *self)
{

    PyNs3SpectrumChannelHelper *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumChannelHelper, &PyNs3SpectrumChannelHelper_Type);
    py_copy->obj = new ns3::SpectrumChannelHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3SpectrumChannelHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumChannelHelper_methods[] = {
    {(char *) "AddSpectrumPropagationLoss", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper_AddSpectrumPropagationLoss, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Default", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper_Default, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Create", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper_Create, METH_NOARGS, NULL },
    {(char *) "SetPropagationDelay", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper_SetPropagationDelay, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddPropagationLoss", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper_AddPropagationLoss, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumChannelHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumChannelHelper__tp_dealloc(PyNs3SpectrumChannelHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3SpectrumChannelHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3SpectrumChannelHelper_wrapper_registry.end()) {
        PyNs3SpectrumChannelHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::SpectrumChannelHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumChannelHelper__tp_richcompare (PyNs3SpectrumChannelHelper *PYBINDGEN_UNUSED(self), PyNs3SpectrumChannelHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumChannelHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumChannelHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumChannelHelper",            /* tp_name */
    sizeof(PyNs3SpectrumChannelHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumChannelHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumChannelHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumChannelHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumChannelHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3SpectrumPhyHelper_wrapper_registry;


static int
_wrap_PyNs3SpectrumPhyHelper__tp_init__0(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumPhyHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumPhyHelper__tp_init__1(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumPhyHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhyHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumPhyHelper(*((PyNs3SpectrumPhyHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumPhyHelper__tp_init(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumPhyHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumPhyHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumPhyHelper_Create(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPhy > retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3NetDevice *device;
    ns3::NetDevice *device_ptr;
    const char *keywords[] = {"node", "device", NULL};
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Node_Type, &node, &PyNs3NetDevice_Type, &device)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    device_ptr = (device ? device->obj : NULL);
    retval = self->obj->Create(ns3::Ptr< ns3::Node  > (node_ptr), ns3::Ptr< ns3::NetDevice  > (device_ptr));
    if (!(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = reinterpret_cast< PyNs3SpectrumPhy* >(reinterpret_cast< PyNs3SpectrumPhy__PythonHelper* >(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval)))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPhy);
    return py_retval;
}



PyObject *
_wrap_PyNs3SpectrumPhyHelper_SetChannel__0(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *channel;
    ns3::SpectrumChannel *channel_ptr;
    const char *keywords[] = {"channel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &channel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    channel_ptr = (channel ? channel->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (channel_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3SpectrumPhyHelper_SetChannel__1(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *channelName;
    Py_ssize_t channelName_len;
    const char *keywords[] = {"channelName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &channelName, &channelName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetChannel(std::string(channelName, channelName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3SpectrumPhyHelper_SetChannel(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumPhyHelper_SetChannel__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumPhyHelper_SetChannel__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3SpectrumPhyHelper_SetPhyAttribute(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *v;
    const char *keywords[] = {"name", "v", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &v)) {
        return NULL;
    }
    self->obj->SetPhyAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) v)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhyHelper_SetPhy(PyNs3SpectrumPhyHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    const char *n0 = NULL;
    Py_ssize_t n0_len;
    PyNs3AttributeValue *v0 = NULL;
    ns3::EmptyAttributeValue v0_default = ns3::EmptyAttributeValue();
    const char *n1 = NULL;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1 = NULL;
    ns3::EmptyAttributeValue v1_default = ns3::EmptyAttributeValue();
    const char *n2 = NULL;
    Py_ssize_t n2_len;
    PyNs3AttributeValue *v2 = NULL;
    ns3::EmptyAttributeValue v2_default = ns3::EmptyAttributeValue();
    const char *n3 = NULL;
    Py_ssize_t n3_len;
    PyNs3AttributeValue *v3 = NULL;
    ns3::EmptyAttributeValue v3_default = ns3::EmptyAttributeValue();
    const char *n4 = NULL;
    Py_ssize_t n4_len;
    PyNs3AttributeValue *v4 = NULL;
    ns3::EmptyAttributeValue v4_default = ns3::EmptyAttributeValue();
    const char *n5 = NULL;
    Py_ssize_t n5_len;
    PyNs3AttributeValue *v5 = NULL;
    ns3::EmptyAttributeValue v5_default = ns3::EmptyAttributeValue();
    const char *n6 = NULL;
    Py_ssize_t n6_len;
    PyNs3AttributeValue *v6 = NULL;
    ns3::EmptyAttributeValue v6_default = ns3::EmptyAttributeValue();
    const char *n7 = NULL;
    Py_ssize_t n7_len;
    PyNs3AttributeValue *v7 = NULL;
    ns3::EmptyAttributeValue v7_default = ns3::EmptyAttributeValue();
    const char *keywords[] = {"name", "n0", "v0", "n1", "v1", "n2", "v2", "n3", "v3", "n4", "v4", "n5", "v5", "n6", "v6", "n7", "v7", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#O!s#O!s#O!s#O!s#O!s#O!s#O!s#O!", (char **) keywords, &name, &name_len, &n0, &n0_len, &PyNs3AttributeValue_Type, &v0, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1, &n2, &n2_len, &PyNs3AttributeValue_Type, &v2, &n3, &n3_len, &PyNs3AttributeValue_Type, &v3, &n4, &n4_len, &PyNs3AttributeValue_Type, &v4, &n5, &n5_len, &PyNs3AttributeValue_Type, &v5, &n6, &n6_len, &PyNs3AttributeValue_Type, &v6, &n7, &n7_len, &PyNs3AttributeValue_Type, &v7)) {
        return NULL;
    }
    self->obj->SetPhy(std::string(name, name_len), (n0 ? std::string(n0, n0_len) : ""), (v0 ? (*((PyNs3AttributeValue *) v0)->obj) : v0_default), (n1 ? std::string(n1, n1_len) : ""), (v1 ? (*((PyNs3AttributeValue *) v1)->obj) : v1_default), (n2 ? std::string(n2, n2_len) : ""), (v2 ? (*((PyNs3AttributeValue *) v2)->obj) : v2_default), (n3 ? std::string(n3, n3_len) : ""), (v3 ? (*((PyNs3AttributeValue *) v3)->obj) : v3_default), (n4 ? std::string(n4, n4_len) : ""), (v4 ? (*((PyNs3AttributeValue *) v4)->obj) : v4_default), (n5 ? std::string(n5, n5_len) : ""), (v5 ? (*((PyNs3AttributeValue *) v5)->obj) : v5_default), (n6 ? std::string(n6, n6_len) : ""), (v6 ? (*((PyNs3AttributeValue *) v6)->obj) : v6_default), (n7 ? std::string(n7, n7_len) : ""), (v7 ? (*((PyNs3AttributeValue *) v7)->obj) : v7_default));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumPhyHelper__copy__(PyNs3SpectrumPhyHelper *self)
{

    PyNs3SpectrumPhyHelper *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumPhyHelper, &PyNs3SpectrumPhyHelper_Type);
    py_copy->obj = new ns3::SpectrumPhyHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3SpectrumPhyHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumPhyHelper_methods[] = {
    {(char *) "Create", (PyCFunction) _wrap_PyNs3SpectrumPhyHelper_Create, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3SpectrumPhyHelper_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPhyAttribute", (PyCFunction) _wrap_PyNs3SpectrumPhyHelper_SetPhyAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPhy", (PyCFunction) _wrap_PyNs3SpectrumPhyHelper_SetPhy, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumPhyHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumPhyHelper__tp_dealloc(PyNs3SpectrumPhyHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3SpectrumPhyHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3SpectrumPhyHelper_wrapper_registry.end()) {
        PyNs3SpectrumPhyHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::SpectrumPhyHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumPhyHelper__tp_richcompare (PyNs3SpectrumPhyHelper *PYBINDGEN_UNUSED(self), PyNs3SpectrumPhyHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumPhyHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumPhyHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumPhyHelper",            /* tp_name */
    sizeof(PyNs3SpectrumPhyHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumPhyHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumPhyHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumPhyHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumPhyHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3TxSpectrumModelInfo_wrapper_registry;
static PyObject* _wrap_PyNs3TxSpectrumModelInfo__get_m_spectrumConverterMap(PyNs3TxSpectrumModelInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    Pyns3__SpectrumConverterMap_t *py_ns3__SpectrumConverterMap_t;
    
    py_ns3__SpectrumConverterMap_t = PyObject_New(Pyns3__SpectrumConverterMap_t, &Pyns3__SpectrumConverterMap_t_Type);
    py_ns3__SpectrumConverterMap_t->obj = new ns3::SpectrumConverterMap_t(self->obj->m_spectrumConverterMap);
    py_retval = Py_BuildValue((char *) "N", py_ns3__SpectrumConverterMap_t);
    return py_retval;
}
static int _wrap_PyNs3TxSpectrumModelInfo__set_m_spectrumConverterMap(PyNs3TxSpectrumModelInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O&", _wrap_convert_py2c__ns3__SpectrumConverterMap_t, &self->obj->m_spectrumConverterMap)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3TxSpectrumModelInfo__get_m_txSpectrumModel(PyNs3TxSpectrumModelInfo *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_txSpectrumModel)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_txSpectrumModel)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_txSpectrumModel)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_txSpectrumModel))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (self->obj->m_txSpectrumModel));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}
static int _wrap_PyNs3TxSpectrumModelInfo__set_m_txSpectrumModel(PyNs3TxSpectrumModelInfo *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumModel *tmp_SpectrumModel;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumModel_Type, &tmp_SpectrumModel)) {
        Py_DECREF(py_retval);
        return -1;
    }
    // dangerous!
    self->obj->m_txSpectrumModel = ns3::Ptr< ns3::SpectrumModel  > (tmp_SpectrumModel->obj);
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3TxSpectrumModelInfo__getsets[] = {
    {
        (char*) "m_txSpectrumModel", /* attribute name */
        (getter) _wrap_PyNs3TxSpectrumModelInfo__get_m_txSpectrumModel, /* C function to get the attribute */
        (setter) _wrap_PyNs3TxSpectrumModelInfo__set_m_txSpectrumModel, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "m_spectrumConverterMap", /* attribute name */
        (getter) _wrap_PyNs3TxSpectrumModelInfo__get_m_spectrumConverterMap, /* C function to get the attribute */
        (setter) _wrap_PyNs3TxSpectrumModelInfo__set_m_spectrumConverterMap, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3TxSpectrumModelInfo__tp_init__0(PyNs3TxSpectrumModelInfo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3TxSpectrumModelInfo *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3TxSpectrumModelInfo_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::TxSpectrumModelInfo(*((PyNs3TxSpectrumModelInfo *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3TxSpectrumModelInfo__tp_init__1(PyNs3TxSpectrumModelInfo *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumModel *txSpectrumModel;
    ns3::SpectrumModel *txSpectrumModel_ptr;
    const char *keywords[] = {"txSpectrumModel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumModel_Type, &txSpectrumModel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    txSpectrumModel_ptr = (txSpectrumModel ? txSpectrumModel->obj : NULL);
    self->obj = new ns3::TxSpectrumModelInfo(ns3::Ptr< ns3::SpectrumModel  > (txSpectrumModel_ptr));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3TxSpectrumModelInfo__tp_init(PyNs3TxSpectrumModelInfo *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3TxSpectrumModelInfo__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3TxSpectrumModelInfo__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyNs3TxSpectrumModelInfo__copy__(PyNs3TxSpectrumModelInfo *self)
{

    PyNs3TxSpectrumModelInfo *py_copy;
    py_copy = PyObject_New(PyNs3TxSpectrumModelInfo, &PyNs3TxSpectrumModelInfo_Type);
    py_copy->obj = new ns3::TxSpectrumModelInfo(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3TxSpectrumModelInfo_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3TxSpectrumModelInfo_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3TxSpectrumModelInfo__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3TxSpectrumModelInfo__tp_dealloc(PyNs3TxSpectrumModelInfo *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3TxSpectrumModelInfo_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3TxSpectrumModelInfo_wrapper_registry.end()) {
        PyNs3TxSpectrumModelInfo_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::TxSpectrumModelInfo *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3TxSpectrumModelInfo__tp_richcompare (PyNs3TxSpectrumModelInfo *PYBINDGEN_UNUSED(self), PyNs3TxSpectrumModelInfo *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3TxSpectrumModelInfo_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3TxSpectrumModelInfo_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.TxSpectrumModelInfo",            /* tp_name */
    sizeof(PyNs3TxSpectrumModelInfo),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3TxSpectrumModelInfo__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3TxSpectrumModelInfo__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3TxSpectrumModelInfo_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3TxSpectrumModelInfo__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3TxSpectrumModelInfo__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3WaveformGeneratorHelper_wrapper_registry;


static int
_wrap_PyNs3WaveformGeneratorHelper__tp_init__0(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3WaveformGeneratorHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3WaveformGeneratorHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::WaveformGeneratorHelper(*((PyNs3WaveformGeneratorHelper *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3WaveformGeneratorHelper__tp_init__1(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::WaveformGeneratorHelper();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3WaveformGeneratorHelper__tp_init(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3WaveformGeneratorHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3WaveformGeneratorHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3WaveformGeneratorHelper_SetDeviceAttribute(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *n1;
    Py_ssize_t n1_len;
    PyNs3AttributeValue *v1;
    const char *keywords[] = {"n1", "v1", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &n1, &n1_len, &PyNs3AttributeValue_Type, &v1)) {
        return NULL;
    }
    self->obj->SetDeviceAttribute(std::string(n1, n1_len), *((PyNs3AttributeValue *) v1)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGeneratorHelper_SetTxPowerSpectralDensity(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *txPsd;
    ns3::SpectrumValue *txPsd_ptr;
    const char *keywords[] = {"txPsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txPsd)) {
        return NULL;
    }
    txPsd_ptr = (txPsd ? txPsd->obj : NULL);
    self->obj->SetTxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (txPsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3WaveformGeneratorHelper_SetChannel__0(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *channel;
    ns3::SpectrumChannel *channel_ptr;
    const char *keywords[] = {"channel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &channel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    channel_ptr = (channel ? channel->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (channel_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
_wrap_PyNs3WaveformGeneratorHelper_SetChannel__1(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *channelName;
    Py_ssize_t channelName_len;
    const char *keywords[] = {"channelName", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &channelName, &channelName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->SetChannel(std::string(channelName, channelName_len));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyNs3WaveformGeneratorHelper_SetChannel(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3WaveformGeneratorHelper_SetChannel__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3WaveformGeneratorHelper_SetChannel__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3WaveformGeneratorHelper_SetPhyAttribute(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    PyNs3AttributeValue *v;
    const char *keywords[] = {"name", "v", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &name, &name_len, &PyNs3AttributeValue_Type, &v)) {
        return NULL;
    }
    self->obj->SetPhyAttribute(std::string(name, name_len), *((PyNs3AttributeValue *) v)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}



PyObject *
_wrap_PyNs3WaveformGeneratorHelper_Install__0(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3NodeContainer *c;
    const char *keywords[] = {"c", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NodeContainer_Type, &c)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::NetDeviceContainer retval = self->obj->Install(*((PyNs3NodeContainer *) c)->obj);
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3WaveformGeneratorHelper_Install__1(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    ns3::NetDeviceContainer retval = self->obj->Install(ns3::Ptr< ns3::Node  > (node_ptr));
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject *
_wrap_PyNs3WaveformGeneratorHelper_Install__2(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    const char *nodeName;
    Py_ssize_t nodeName_len;
    const char *keywords[] = {"nodeName", NULL};
    PyNs3NetDeviceContainer *py_NetDeviceContainer;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &nodeName, &nodeName_len)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::NetDeviceContainer retval = self->obj->Install(std::string(nodeName, nodeName_len));
    py_NetDeviceContainer = PyObject_New(PyNs3NetDeviceContainer, &PyNs3NetDeviceContainer_Type);
    py_NetDeviceContainer->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_NetDeviceContainer->obj = new ns3::NetDeviceContainer(retval);
    PyNs3NetDeviceContainer_wrapper_registry[(void *) py_NetDeviceContainer->obj] = (PyObject *) py_NetDeviceContainer;
    py_retval = Py_BuildValue((char *) "N", py_NetDeviceContainer);
    return py_retval;
}

PyObject * _wrap_PyNs3WaveformGeneratorHelper_Install(PyNs3WaveformGeneratorHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3WaveformGeneratorHelper_Install__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3WaveformGeneratorHelper_Install__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3WaveformGeneratorHelper_Install__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


static PyObject*
_wrap_PyNs3WaveformGeneratorHelper__copy__(PyNs3WaveformGeneratorHelper *self)
{

    PyNs3WaveformGeneratorHelper *py_copy;
    py_copy = PyObject_New(PyNs3WaveformGeneratorHelper, &PyNs3WaveformGeneratorHelper_Type);
    py_copy->obj = new ns3::WaveformGeneratorHelper(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3WaveformGeneratorHelper_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3WaveformGeneratorHelper_methods[] = {
    {(char *) "SetDeviceAttribute", (PyCFunction) _wrap_PyNs3WaveformGeneratorHelper_SetDeviceAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetTxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3WaveformGeneratorHelper_SetTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3WaveformGeneratorHelper_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPhyAttribute", (PyCFunction) _wrap_PyNs3WaveformGeneratorHelper_SetPhyAttribute, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Install", (PyCFunction) _wrap_PyNs3WaveformGeneratorHelper_Install, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3WaveformGeneratorHelper__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3WaveformGeneratorHelper__tp_dealloc(PyNs3WaveformGeneratorHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3WaveformGeneratorHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3WaveformGeneratorHelper_wrapper_registry.end()) {
        PyNs3WaveformGeneratorHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
        ns3::WaveformGeneratorHelper *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3WaveformGeneratorHelper__tp_richcompare (PyNs3WaveformGeneratorHelper *PYBINDGEN_UNUSED(self), PyNs3WaveformGeneratorHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3WaveformGeneratorHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3WaveformGeneratorHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.WaveformGeneratorHelper",            /* tp_name */
    sizeof(PyNs3WaveformGeneratorHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3WaveformGeneratorHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3WaveformGeneratorHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3WaveformGeneratorHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3WaveformGeneratorHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry;

PyObject *
PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::_wrap_CreateRfFilter(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    unsigned int channel;
    PyNs3WifiSpectrumValue5MhzFactory__PythonHelper *helper = dynamic_cast< PyNs3WifiSpectrumValue5MhzFactory__PythonHelper* >(self->obj);
    const char *keywords[] = {"channel", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &channel)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method CreateRfFilter of class WifiSpectrumValue5MhzFactory is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->CreateRfFilter__parent_caller(channel);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

PyObject *
PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::_wrap_CreateTxPowerSpectralDensity(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    double txPower;
    unsigned int channel;
    PyNs3WifiSpectrumValue5MhzFactory__PythonHelper *helper = dynamic_cast< PyNs3WifiSpectrumValue5MhzFactory__PythonHelper* >(self->obj);
    const char *keywords[] = {"txPower", "channel", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dI", (char **) keywords, &txPower, &channel)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method CreateTxPowerSpectralDensity of class WifiSpectrumValue5MhzFactory is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->CreateTxPowerSpectralDensity__parent_caller(txPower, channel);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

PyObject *
PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::_wrap_CreateConstant(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    double psd;
    PyNs3WifiSpectrumValue5MhzFactory__PythonHelper *helper = dynamic_cast< PyNs3WifiSpectrumValue5MhzFactory__PythonHelper* >(self->obj);
    const char *keywords[] = {"psd", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &psd)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method CreateConstant of class WifiSpectrumValue5MhzFactory is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->CreateConstant__parent_caller(psd);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::CreateConstant(double psd)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WifiSpectrumValue5MhzFactory *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_CreateConstant"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateConstant(psd);
    }
    self_obj_before = reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = (ns3::WifiSpectrumValue5MhzFactory*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_CreateConstant", (char *) "d", psd);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateConstant(psd);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateConstant(psd);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::CreateRfFilter(uint32_t channel)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WifiSpectrumValue5MhzFactory *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_CreateRfFilter"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateRfFilter(channel);
    }
    self_obj_before = reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = (ns3::WifiSpectrumValue5MhzFactory*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_CreateRfFilter", (char *) "N", PyLong_FromUnsignedLong(channel));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateRfFilter(channel);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateRfFilter(channel);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::CreateTxPowerSpectralDensity(double txPower, uint32_t channel)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WifiSpectrumValue5MhzFactory *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_CreateTxPowerSpectralDensity"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateTxPowerSpectralDensity(txPower, channel);
    }
    self_obj_before = reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = (ns3::WifiSpectrumValue5MhzFactory*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_CreateTxPowerSpectralDensity", (char *) "dN", txPower, PyLong_FromUnsignedLong(channel));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateTxPowerSpectralDensity(txPower, channel);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WifiSpectrumValue5MhzFactory::CreateTxPowerSpectralDensity(txPower, channel);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WifiSpectrumValue5MhzFactory* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}


static int
_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_init__0(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3WifiSpectrumValue5MhzFactory_Type)
    {
        self->obj = new PyNs3WifiSpectrumValue5MhzFactory__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3WifiSpectrumValue5MhzFactory__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        self->obj = new ns3::WifiSpectrumValue5MhzFactory();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    }
    return 0;
}

static int
_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_init__1(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3WifiSpectrumValue5MhzFactory *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3WifiSpectrumValue5MhzFactory_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3WifiSpectrumValue5MhzFactory_Type)
    {
        self->obj = new PyNs3WifiSpectrumValue5MhzFactory__PythonHelper(*((PyNs3WifiSpectrumValue5MhzFactory *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3WifiSpectrumValue5MhzFactory__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        self->obj = new ns3::WifiSpectrumValue5MhzFactory(*((PyNs3WifiSpectrumValue5MhzFactory *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    }
    return 0;
}

int _wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_init(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3WifiSpectrumValue5MhzFactory_CreateRfFilter(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    unsigned int channel;
    const char *keywords[] = {"channel", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &channel)) {
        return NULL;
    }
    retval = self->obj->CreateRfFilter(channel);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3WifiSpectrumValue5MhzFactory_CreateTxPowerSpectralDensity(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    double txPower;
    unsigned int channel;
    const char *keywords[] = {"txPower", "channel", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dI", (char **) keywords, &txPower, &channel)) {
        return NULL;
    }
    retval = self->obj->CreateTxPowerSpectralDensity(txPower, channel);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3WifiSpectrumValue5MhzFactory_CreateConstant(PyNs3WifiSpectrumValue5MhzFactory *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    double psd;
    const char *keywords[] = {"psd", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &psd)) {
        return NULL;
    }
    retval = self->obj->CreateConstant(psd);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


static PyObject*
_wrap_PyNs3WifiSpectrumValue5MhzFactory__copy__(PyNs3WifiSpectrumValue5MhzFactory *self)
{

    PyNs3WifiSpectrumValue5MhzFactory *py_copy;
    py_copy = PyObject_GC_New(PyNs3WifiSpectrumValue5MhzFactory, &PyNs3WifiSpectrumValue5MhzFactory_Type);
    py_copy->obj = new ns3::WifiSpectrumValue5MhzFactory(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3WifiSpectrumValue5MhzFactory_methods[] = {
    {(char *) "CreateRfFilter", (PyCFunction) _wrap_PyNs3WifiSpectrumValue5MhzFactory_CreateRfFilter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateTxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3WifiSpectrumValue5MhzFactory_CreateTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateConstant", (PyCFunction) _wrap_PyNs3WifiSpectrumValue5MhzFactory_CreateConstant, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_CreateRfFilter", (PyCFunction) PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::_wrap_CreateRfFilter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_CreateTxPowerSpectralDensity", (PyCFunction) PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::_wrap_CreateTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_CreateConstant", (PyCFunction) PyNs3WifiSpectrumValue5MhzFactory__PythonHelper::_wrap_CreateConstant, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3WifiSpectrumValue5MhzFactory__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3WifiSpectrumValue5MhzFactory__tp_clear(PyNs3WifiSpectrumValue5MhzFactory *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::WifiSpectrumValue5MhzFactory *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3WifiSpectrumValue5MhzFactory__tp_traverse(PyNs3WifiSpectrumValue5MhzFactory *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3WifiSpectrumValue5MhzFactory__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_dealloc(PyNs3WifiSpectrumValue5MhzFactory *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry.end()) {
        PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3WifiSpectrumValue5MhzFactory__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_richcompare (PyNs3WifiSpectrumValue5MhzFactory *PYBINDGEN_UNUSED(self), PyNs3WifiSpectrumValue5MhzFactory *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3WifiSpectrumValue5MhzFactory_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3WifiSpectrumValue5MhzFactory_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.WifiSpectrumValue5MhzFactory",            /* tp_name */
    sizeof(PyNs3WifiSpectrumValue5MhzFactory),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3WifiSpectrumValue5MhzFactory__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3WifiSpectrumValue5MhzFactory__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3WifiSpectrumValue5MhzFactory_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3WifiSpectrumValue5MhzFactory, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3WifiSpectrumValue5MhzFactory__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



std::map<void*, PyObject*> PyNs3WifiSpectrumValueHelper_wrapper_registry;

ns3::Ptr< ns3::SpectrumValue >
PyNs3WifiSpectrumValueHelper__PythonHelper::CreateConstant(double psd)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WifiSpectrumValueHelper *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_CreateConstant"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = (ns3::WifiSpectrumValueHelper*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_CreateConstant", (char *) "d", psd);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3WifiSpectrumValueHelper__PythonHelper::CreateRfFilter(uint32_t channel)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WifiSpectrumValueHelper *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_CreateRfFilter"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = (ns3::WifiSpectrumValueHelper*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_CreateRfFilter", (char *) "N", PyLong_FromUnsignedLong(channel));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3WifiSpectrumValueHelper__PythonHelper::CreateTxPowerSpectralDensity(double txPower, uint32_t channel)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WifiSpectrumValueHelper *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_CreateTxPowerSpectralDensity"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = (ns3::WifiSpectrumValueHelper*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_CreateTxPowerSpectralDensity", (char *) "dN", txPower, PyLong_FromUnsignedLong(channel));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WifiSpectrumValueHelper* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}


static int
_wrap_PyNs3WifiSpectrumValueHelper__tp_init__0(PyNs3WifiSpectrumValueHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3WifiSpectrumValueHelper_Type)
    {
        self->obj = new PyNs3WifiSpectrumValueHelper__PythonHelper();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3WifiSpectrumValueHelper__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'WifiSpectrumValueHelper' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3WifiSpectrumValueHelper__tp_init__1(PyNs3WifiSpectrumValueHelper *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3WifiSpectrumValueHelper *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3WifiSpectrumValueHelper_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3WifiSpectrumValueHelper_Type)
    {
        self->obj = new PyNs3WifiSpectrumValueHelper__PythonHelper(*((PyNs3WifiSpectrumValueHelper *) arg0)->obj);
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3WifiSpectrumValueHelper__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'WifiSpectrumValueHelper' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3WifiSpectrumValueHelper__tp_init(PyNs3WifiSpectrumValueHelper *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3WifiSpectrumValueHelper__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3WifiSpectrumValueHelper__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3WifiSpectrumValueHelper_CreateRfFilter(PyNs3WifiSpectrumValueHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    unsigned int channel;
    const char *keywords[] = {"channel", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &channel)) {
        return NULL;
    }
    retval = self->obj->CreateRfFilter(channel);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3WifiSpectrumValueHelper_CreateTxPowerSpectralDensity(PyNs3WifiSpectrumValueHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    double txPower;
    unsigned int channel;
    const char *keywords[] = {"txPower", "channel", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dI", (char **) keywords, &txPower, &channel)) {
        return NULL;
    }
    retval = self->obj->CreateTxPowerSpectralDensity(txPower, channel);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3WifiSpectrumValueHelper_CreateConstant(PyNs3WifiSpectrumValueHelper *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    double psd;
    const char *keywords[] = {"psd", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &psd)) {
        return NULL;
    }
    retval = self->obj->CreateConstant(psd);
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

static PyMethodDef PyNs3WifiSpectrumValueHelper_methods[] = {
    {(char *) "CreateRfFilter", (PyCFunction) _wrap_PyNs3WifiSpectrumValueHelper_CreateRfFilter, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateTxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3WifiSpectrumValueHelper_CreateTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CreateConstant", (PyCFunction) _wrap_PyNs3WifiSpectrumValueHelper_CreateConstant, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3WifiSpectrumValueHelper__tp_clear(PyNs3WifiSpectrumValueHelper *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::WifiSpectrumValueHelper *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3WifiSpectrumValueHelper__tp_traverse(PyNs3WifiSpectrumValueHelper *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3WifiSpectrumValueHelper__PythonHelper).name() )
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3WifiSpectrumValueHelper__tp_dealloc(PyNs3WifiSpectrumValueHelper *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3WifiSpectrumValueHelper_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3WifiSpectrumValueHelper_wrapper_registry.end()) {
        PyNs3WifiSpectrumValueHelper_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3WifiSpectrumValueHelper__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3WifiSpectrumValueHelper__tp_richcompare (PyNs3WifiSpectrumValueHelper *PYBINDGEN_UNUSED(self), PyNs3WifiSpectrumValueHelper *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3WifiSpectrumValueHelper_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3WifiSpectrumValueHelper_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.WifiSpectrumValueHelper",            /* tp_name */
    sizeof(PyNs3WifiSpectrumValueHelper),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3WifiSpectrumValueHelper__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3WifiSpectrumValueHelper__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3WifiSpectrumValueHelper__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3WifiSpectrumValueHelper__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3WifiSpectrumValueHelper_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3WifiSpectrumValueHelper, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3WifiSpectrumValueHelper__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_init__0(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_init__1(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> >(*((PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_init(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____copy__(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__, &PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_init__0(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_init__1(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >(*((PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_init(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____copy__(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__, &PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_init__0(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_init__1(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >(*((PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_init(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____copy__(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__, &PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




pybindgen::TypeMap PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map;



static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_init__0(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_init__1(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *o;
    const char *keywords[] = {"o", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type, &o)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >(*((PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *) o)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_init(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Cleanup(void)
{
    PyObject *py_retval;
    
    ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >::Cleanup();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____copy__(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *self)
{

    PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *py_copy;
    py_copy = PyObject_New(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__, &PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type);
    py_copy->obj = new ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___methods[] = {
    {(char *) "Cleanup", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Cleanup, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_dealloc(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> > *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_richcompare (PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *PYBINDGEN_UNUSED(self), PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__ *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__",            /* tp_name */
    sizeof(PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3SpectrumConverter__tp_init__0(PyNs3SpectrumConverter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumConverter *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumConverter_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumConverter(*((PyNs3SpectrumConverter *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumConverter__tp_init__1(PyNs3SpectrumConverter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumModel *fromSpectrumModel;
    ns3::SpectrumModel *fromSpectrumModel_ptr;
    PyNs3SpectrumModel *toSpectrumModel;
    ns3::SpectrumModel *toSpectrumModel_ptr;
    const char *keywords[] = {"fromSpectrumModel", "toSpectrumModel", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3SpectrumModel_Type, &fromSpectrumModel, &PyNs3SpectrumModel_Type, &toSpectrumModel)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    fromSpectrumModel_ptr = (fromSpectrumModel ? fromSpectrumModel->obj : NULL);
    toSpectrumModel_ptr = (toSpectrumModel ? toSpectrumModel->obj : NULL);
    self->obj = new ns3::SpectrumConverter(ns3::Ptr< ns3::SpectrumModel  > (fromSpectrumModel_ptr), ns3::Ptr< ns3::SpectrumModel  > (toSpectrumModel_ptr));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumConverter__tp_init__2(PyNs3SpectrumConverter *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumConverter();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumConverter__tp_init(PyNs3SpectrumConverter *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3SpectrumConverter__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumConverter__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3SpectrumConverter__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumConverter_Convert(PyNs3SpectrumConverter *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *vvf;
    ns3::SpectrumValue *vvf_ptr;
    const char *keywords[] = {"vvf", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &vvf)) {
        return NULL;
    }
    vvf_ptr = (vvf ? vvf->obj : NULL);
    retval = self->obj->Convert(ns3::Ptr< ns3::SpectrumValue  > (vvf_ptr));
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumConverter__copy__(PyNs3SpectrumConverter *self)
{

    PyNs3SpectrumConverter *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumConverter, &PyNs3SpectrumConverter_Type);
    py_copy->obj = new ns3::SpectrumConverter(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumConverter_methods[] = {
    {(char *) "Convert", (PyCFunction) _wrap_PyNs3SpectrumConverter_Convert, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumConverter__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumConverter__tp_dealloc(PyNs3SpectrumConverter *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SpectrumConverter *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumConverter__tp_richcompare (PyNs3SpectrumConverter *PYBINDGEN_UNUSED(self), PyNs3SpectrumConverter *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumConverter_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumConverter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumConverter",            /* tp_name */
    sizeof(PyNs3SpectrumConverter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumConverter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumConverter__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumConverter_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumConverter__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SpectrumErrorModel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumErrorModel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumErrorModel__PythonHelper::_wrap_DoDispose(PyNs3SpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumErrorModel__PythonHelper::_wrap_DoStart(PyNs3SpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumErrorModel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumErrorModel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

void
PyNs3SpectrumErrorModel__PythonHelper::EvaluateChunk(ns3::SpectrumValue const & sinr, ns3::Time duration)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    PyNs3Time *py_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_EvaluateChunk"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = (ns3::SpectrumErrorModel*) this;
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(sinr);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(duration);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_EvaluateChunk", (char *) "NN", py_SpectrumValue, py_Time);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3SpectrumErrorModel__PythonHelper::IsRxCorrect()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsRxCorrect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = (ns3::SpectrumErrorModel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsRxCorrect", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumErrorModel__PythonHelper::StartRx(ns3::Ptr< ns3::Packet const > p)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = (ns3::SpectrumErrorModel*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "N", py_Packet);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3SpectrumErrorModel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumErrorModel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumErrorModel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumErrorModel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumErrorModel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SpectrumErrorModel__tp_init__0(PyNs3SpectrumErrorModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumErrorModel_Type)
    {
        self->obj = new PyNs3SpectrumErrorModel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumErrorModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumErrorModel' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3SpectrumErrorModel__tp_init__1(PyNs3SpectrumErrorModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumErrorModel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumErrorModel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumErrorModel_Type)
    {
        self->obj = new PyNs3SpectrumErrorModel__PythonHelper(*((PyNs3SpectrumErrorModel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumErrorModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumErrorModel' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3SpectrumErrorModel__tp_init(PyNs3SpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumErrorModel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumErrorModel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumErrorModel_IsRxCorrect(PyNs3SpectrumErrorModel *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsRxCorrect();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumErrorModel_EvaluateChunk(PyNs3SpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *sinr;
    PyNs3Time *duration;
    const char *keywords[] = {"sinr", "duration", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &sinr, &PyNs3Time_Type, &duration)) {
        return NULL;
    }
    self->obj->EvaluateChunk(*((PyNs3SpectrumValue *) sinr)->obj, *((PyNs3Time *) duration)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumErrorModel_StartRx(PyNs3SpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3SpectrumErrorModel_methods[] = {
    {(char *) "IsRxCorrect", (PyCFunction) _wrap_PyNs3SpectrumErrorModel_IsRxCorrect, METH_NOARGS, NULL },
    {(char *) "EvaluateChunk", (PyCFunction) _wrap_PyNs3SpectrumErrorModel_EvaluateChunk, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3SpectrumErrorModel_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SpectrumErrorModel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SpectrumErrorModel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3SpectrumErrorModel__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SpectrumErrorModel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SpectrumErrorModel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SpectrumErrorModel__tp_clear(PyNs3SpectrumErrorModel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SpectrumErrorModel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SpectrumErrorModel__tp_traverse(PyNs3SpectrumErrorModel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SpectrumErrorModel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SpectrumErrorModel__tp_dealloc(PyNs3SpectrumErrorModel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SpectrumErrorModel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumErrorModel__tp_richcompare (PyNs3SpectrumErrorModel *PYBINDGEN_UNUSED(self), PyNs3SpectrumErrorModel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumErrorModel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumErrorModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumErrorModel",            /* tp_name */
    sizeof(PyNs3SpectrumErrorModel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumErrorModel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SpectrumErrorModel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SpectrumErrorModel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumErrorModel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumErrorModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SpectrumErrorModel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumErrorModel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SpectrumInterference__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    PyNs3SpectrumInterference__PythonHelper *helper = dynamic_cast< PyNs3SpectrumInterference__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumInterference__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    PyNs3SpectrumInterference__PythonHelper *helper = dynamic_cast< PyNs3SpectrumInterference__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumInterference__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    PyNs3SpectrumInterference__PythonHelper *helper = dynamic_cast< PyNs3SpectrumInterference__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3SpectrumInterference__PythonHelper::_wrap_DoStart(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    PyNs3SpectrumInterference__PythonHelper *helper = dynamic_cast< PyNs3SpectrumInterference__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumInterference__PythonHelper::_wrap_DoDispose(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    PyNs3SpectrumInterference__PythonHelper *helper = dynamic_cast< PyNs3SpectrumInterference__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class SpectrumInterference is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3SpectrumInterference__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumInterference *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumInterference::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumInterference* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumInterference* >(m_pyself)->obj = (ns3::SpectrumInterference*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumInterference* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumInterference* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumInterference* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3SpectrumInterference__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumInterference__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumInterference__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumInterference__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SpectrumInterference__tp_init__0(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumInterference *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumInterference_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumInterference_Type)
    {
        self->obj = new PyNs3SpectrumInterference__PythonHelper(*((PyNs3SpectrumInterference *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumInterference__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::SpectrumInterference(*((PyNs3SpectrumInterference *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3SpectrumInterference__tp_init__1(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumInterference_Type)
    {
        self->obj = new PyNs3SpectrumInterference__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumInterference__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::SpectrumInterference();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3SpectrumInterference__tp_init(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumInterference__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumInterference__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumInterference_AddSignal(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *spd;
    ns3::SpectrumValue *spd_ptr;
    PyNs3Time *duration;
    const char *keywords[] = {"spd", "duration", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &spd, &PyNs3Time_Type, &duration)) {
        return NULL;
    }
    spd_ptr = (spd ? spd->obj : NULL);
    self->obj->AddSignal(ns3::Ptr< ns3::SpectrumValue  > (spd_ptr), *((PyNs3Time *) duration)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumInterference_AbortRx(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    
    self->obj->AbortRx();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumInterference_EndRx(PyNs3SpectrumInterference *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->EndRx();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumInterference_StartRx(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3SpectrumValue *rxPsd;
    ns3::SpectrumValue *rxPsd_ptr;
    const char *keywords[] = {"p", "rxPsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3Packet_Type, &p, &PyNs3SpectrumValue_Type, &rxPsd)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    rxPsd_ptr = (rxPsd ? rxPsd->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::Packet  > (p_ptr), ns3::Ptr< ns3::SpectrumValue  > (rxPsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumInterference_SetNoisePowerSpectralDensity(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *noisePsd;
    ns3::SpectrumValue *noisePsd_ptr;
    const char *keywords[] = {"noisePsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &noisePsd)) {
        return NULL;
    }
    noisePsd_ptr = (noisePsd ? noisePsd->obj : NULL);
    self->obj->SetNoisePowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (noisePsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumInterference_SetErrorModel(PyNs3SpectrumInterference *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumErrorModel *e;
    ns3::SpectrumErrorModel *e_ptr;
    const char *keywords[] = {"e", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumErrorModel_Type, &e)) {
        return NULL;
    }
    e_ptr = (e ? e->obj : NULL);
    self->obj->SetErrorModel(ns3::Ptr< ns3::SpectrumErrorModel  > (e_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumInterference__copy__(PyNs3SpectrumInterference *self)
{

    PyNs3SpectrumInterference *py_copy;
    py_copy = PyObject_GC_New(PyNs3SpectrumInterference, &PyNs3SpectrumInterference_Type);
    py_copy->obj = new ns3::SpectrumInterference(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumInterference_methods[] = {
    {(char *) "AddSignal", (PyCFunction) _wrap_PyNs3SpectrumInterference_AddSignal, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AbortRx", (PyCFunction) _wrap_PyNs3SpectrumInterference_AbortRx, METH_NOARGS, NULL },
    {(char *) "EndRx", (PyCFunction) _wrap_PyNs3SpectrumInterference_EndRx, METH_NOARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3SpectrumInterference_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNoisePowerSpectralDensity", (PyCFunction) _wrap_PyNs3SpectrumInterference_SetNoisePowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetErrorModel", (PyCFunction) _wrap_PyNs3SpectrumInterference_SetErrorModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SpectrumInterference__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SpectrumInterference__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SpectrumInterference__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SpectrumInterference__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3SpectrumInterference__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumInterference__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SpectrumInterference__tp_clear(PyNs3SpectrumInterference *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SpectrumInterference *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SpectrumInterference__tp_traverse(PyNs3SpectrumInterference *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SpectrumInterference__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SpectrumInterference__tp_dealloc(PyNs3SpectrumInterference *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SpectrumInterference__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumInterference__tp_richcompare (PyNs3SpectrumInterference *PYBINDGEN_UNUSED(self), PyNs3SpectrumInterference *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumInterference_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumInterference_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumInterference",            /* tp_name */
    sizeof(PyNs3SpectrumInterference),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumInterference__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SpectrumInterference__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SpectrumInterference__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumInterference__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumInterference_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SpectrumInterference, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumInterference__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3SpectrumModel__tp_init__0(PyNs3SpectrumModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumModel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumModel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumModel(*((PyNs3SpectrumModel *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumModel__tp_init__1(PyNs3SpectrumModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    std::vector< double > centerFreqs_value;
    const char *keywords[] = {"centerFreqs", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__std__vector__lt___double___gt__, &centerFreqs_value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumModel(centerFreqs_value);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumModel__tp_init__2(PyNs3SpectrumModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    ns3::Bands bands_value;
    const char *keywords[] = {"bands", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__ns3__Bands, &bands_value)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumModel(bands_value);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumModel__tp_init(PyNs3SpectrumModel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3SpectrumModel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumModel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3SpectrumModel__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumModel_GetNumBands(PyNs3SpectrumModel *self)
{
    PyObject *py_retval;
    size_t retval;
    
    retval = self->obj->GetNumBands();
    py_retval = Py_BuildValue((char *) "K", ((unsigned PY_LONG_LONG) retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumModel_GetUid(PyNs3SpectrumModel *self)
{
    PyObject *py_retval;
    ns3::SpectrumModelUid_t retval;
    
    retval = self->obj->GetUid();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumModel__copy__(PyNs3SpectrumModel *self)
{

    PyNs3SpectrumModel *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumModel, &PyNs3SpectrumModel_Type);
    py_copy->obj = new ns3::SpectrumModel(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumModel_methods[] = {
    {(char *) "GetNumBands", (PyCFunction) _wrap_PyNs3SpectrumModel_GetNumBands, METH_NOARGS, NULL },
    {(char *) "GetUid", (PyCFunction) _wrap_PyNs3SpectrumModel_GetUid, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumModel__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumModel__tp_dealloc(PyNs3SpectrumModel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SpectrumModel *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumModel__tp_richcompare (PyNs3SpectrumModel *PYBINDGEN_UNUSED(self), PyNs3SpectrumModel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumModel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        if (*self->obj == *other->obj) {
            Py_INCREF(Py_True);
            return Py_True;
        } else {
            Py_INCREF(Py_False);
            return Py_False;
        }
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumModel",            /* tp_name */
    sizeof(PyNs3SpectrumModel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumModel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumModel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumModel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SpectrumPhy__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPhy__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPhy__PythonHelper::_wrap_DoDispose(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPhy__PythonHelper::_wrap_DoStart(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPhy__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPhy__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3SpectrumPhy__PythonHelper::GetDevice()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = (ns3::SpectrumPhy*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::MobilityModel >
PyNs3SpectrumPhy__PythonHelper::GetMobility()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *tmp_MobilityModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = (ns3::SpectrumPhy*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMobility", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3MobilityModel_Type, &tmp_MobilityModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::MobilityModel  > (tmp_MobilityModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumModel const >
PyNs3SpectrumPhy__PythonHelper::GetRxSpectrumModel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *tmp_SpectrumModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetRxSpectrumModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = const_cast< ns3::SpectrumPhy* >((const ns3::SpectrumPhy*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetRxSpectrumModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumModel_Type, &tmp_SpectrumModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumModel  > (tmp_SpectrumModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumPhy__PythonHelper::SetChannel(ns3::Ptr< ns3::SpectrumChannel > c)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumChannel *py_SpectrumChannel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = (ns3::SpectrumPhy*) this;
    if (typeid(*(const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))).name() == typeid(PyNs3SpectrumChannel__PythonHelper).name())
    {
        py_SpectrumChannel = (PyNs3SpectrumChannel*) (((PyNs3SpectrumChannel__PythonHelper*) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))->m_pyself);
        py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
        Py_INCREF(py_SpectrumChannel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumChannel = NULL;
        } else {
            py_SpectrumChannel = (PyNs3SpectrumChannel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumChannel);
        }
    
        if (py_SpectrumChannel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))), &PyNs3SpectrumChannel_Type);
            py_SpectrumChannel = PyObject_GC_New(PyNs3SpectrumChannel, wrapper_type);
            py_SpectrumChannel->inst_dict = NULL;
            py_SpectrumChannel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))->Ref();
            py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumChannel->obj] = (PyObject *) py_SpectrumChannel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetChannel", (char *) "N", py_SpectrumChannel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPhy__PythonHelper::SetDevice(ns3::Ptr< ns3::NetDevice > d)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = (ns3::SpectrumPhy*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPhy__PythonHelper::SetMobility(ns3::Ptr< ns3::MobilityModel > m)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = (ns3::SpectrumPhy*) this;
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetMobility", (char *) "N", py_MobilityModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPhy__PythonHelper::StartRx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = (ns3::SpectrumPhy*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3SpectrumPhy__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumPhy__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPhy__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPhy__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPhy__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SpectrumPhy__tp_init__0(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumPhy_Type)
    {
        self->obj = new PyNs3SpectrumPhy__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumPhy__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumPhy' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3SpectrumPhy__tp_init__1(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumPhy *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhy_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumPhy_Type)
    {
        self->obj = new PyNs3SpectrumPhy__PythonHelper(*((PyNs3SpectrumPhy *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumPhy__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumPhy' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3SpectrumPhy__tp_init(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumPhy__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumPhy__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumPhy_GetRxSpectrumModel(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRxSpectrumModel();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_SetMobility(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->SetMobility(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::SpectrumPhy::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_SetChannel(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_StartRx(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_SetDevice(PyNs3SpectrumPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_GetMobility(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetMobility();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPhy_GetDevice(PyNs3SpectrumPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

static PyMethodDef PyNs3SpectrumPhy_methods[] = {
    {(char *) "GetRxSpectrumModel", (PyCFunction) _wrap_PyNs3SpectrumPhy_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "SetMobility", (PyCFunction) _wrap_PyNs3SpectrumPhy_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3SpectrumPhy_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3SpectrumPhy_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3SpectrumPhy_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3SpectrumPhy_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMobility", (PyCFunction) _wrap_PyNs3SpectrumPhy_GetMobility, METH_NOARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3SpectrumPhy_GetDevice, METH_NOARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SpectrumPhy__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SpectrumPhy__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3SpectrumPhy__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SpectrumPhy__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SpectrumPhy__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SpectrumPhy__tp_clear(PyNs3SpectrumPhy *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SpectrumPhy *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SpectrumPhy__tp_traverse(PyNs3SpectrumPhy *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SpectrumPhy__tp_dealloc(PyNs3SpectrumPhy *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SpectrumPhy__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumPhy__tp_richcompare (PyNs3SpectrumPhy *PYBINDGEN_UNUSED(self), PyNs3SpectrumPhy *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumPhy_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumPhy_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumPhy",            /* tp_name */
    sizeof(PyNs3SpectrumPhy),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumPhy__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SpectrumPhy__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SpectrumPhy__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumPhy__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumPhy_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SpectrumPhy, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumPhy__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_DoStart(PyNs3SpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_DoDispose(PyNs3SpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class SpectrumPropagationLossModel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3SpectrumPropagationLossModel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPropagationLossModel *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumPropagationLossModel::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = (ns3::SpectrumPropagationLossModel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3SpectrumPropagationLossModel__PythonHelper::DoCalcRxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue const > txPsd, ns3::Ptr< ns3::MobilityModel const > a, ns3::Ptr< ns3::MobilityModel const > b) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPropagationLossModel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    PyNs3MobilityModel *py_MobilityModel2;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter3;
    PyTypeObject *wrapper_type3 = 0;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoCalcRxPowerSpectralDensity"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = const_cast< ns3::SpectrumPropagationLossModel* >((const ns3::SpectrumPropagationLossModel*) this);
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter2->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type2);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel2 = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b)))->m_pyself);
        py_MobilityModel2->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b));
        Py_INCREF(py_MobilityModel2);
    } else {
        wrapper_lookup_iter3 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b)));
        if (wrapper_lookup_iter3 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel2 = NULL;
        } else {
            py_MobilityModel2 = (PyNs3MobilityModel *) wrapper_lookup_iter3->second;
            Py_INCREF(py_MobilityModel2);
        }
    
        if (py_MobilityModel2 == NULL)
        {
            wrapper_type3 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b))), &PyNs3MobilityModel_Type);
            py_MobilityModel2 = PyObject_GC_New(PyNs3MobilityModel, wrapper_type3);
            py_MobilityModel2->inst_dict = NULL;
            py_MobilityModel2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b))->Ref();
            py_MobilityModel2->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel2->obj] = (PyObject *) py_MobilityModel2;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoCalcRxPowerSpectralDensity", (char *) "NNN", py_SpectrumValue, py_MobilityModel, py_MobilityModel2);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::TypeId
PyNs3SpectrumPropagationLossModel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumPropagationLossModel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPropagationLossModel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumPropagationLossModel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SpectrumPropagationLossModel__tp_init__0(PyNs3SpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumPropagationLossModel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumPropagationLossModel_Type)
    {
        self->obj = new PyNs3SpectrumPropagationLossModel__PythonHelper(*((PyNs3SpectrumPropagationLossModel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumPropagationLossModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumPropagationLossModel' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3SpectrumPropagationLossModel__tp_init__1(PyNs3SpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumPropagationLossModel_Type)
    {
        self->obj = new PyNs3SpectrumPropagationLossModel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumPropagationLossModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumPropagationLossModel' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3SpectrumPropagationLossModel__tp_init(PyNs3SpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumPropagationLossModel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumPropagationLossModel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumPropagationLossModel_CalcRxPowerSpectralDensity(PyNs3SpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *txPsd;
    ns3::SpectrumValue *txPsd_ptr;
    PyNs3MobilityModel *a;
    ns3::MobilityModel *a_ptr;
    PyNs3MobilityModel *b;
    ns3::MobilityModel *b_ptr;
    const char *keywords[] = {"txPsd", "a", "b", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txPsd, &PyNs3MobilityModel_Type, &a, &PyNs3MobilityModel_Type, &b)) {
        return NULL;
    }
    txPsd_ptr = (txPsd ? txPsd->obj : NULL);
    a_ptr = (a ? a->obj : NULL);
    b_ptr = (b ? b->obj : NULL);
    retval = self->obj->CalcRxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (txPsd_ptr), ns3::Ptr< ns3::MobilityModel  > (a_ptr), ns3::Ptr< ns3::MobilityModel  > (b_ptr));
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPropagationLossModel_SetNext(PyNs3SpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *next;
    ns3::SpectrumPropagationLossModel *next_ptr;
    const char *keywords[] = {"next", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &next)) {
        return NULL;
    }
    next_ptr = (next ? next->obj : NULL);
    self->obj->SetNext(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (next_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumPropagationLossModel_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::SpectrumPropagationLossModel::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

static PyMethodDef PyNs3SpectrumPropagationLossModel_methods[] = {
    {(char *) "CalcRxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3SpectrumPropagationLossModel_CalcRxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNext", (PyCFunction) _wrap_PyNs3SpectrumPropagationLossModel_SetNext, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3SpectrumPropagationLossModel_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3SpectrumPropagationLossModel__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SpectrumPropagationLossModel__tp_clear(PyNs3SpectrumPropagationLossModel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SpectrumPropagationLossModel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SpectrumPropagationLossModel__tp_traverse(PyNs3SpectrumPropagationLossModel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SpectrumPropagationLossModel__tp_dealloc(PyNs3SpectrumPropagationLossModel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SpectrumPropagationLossModel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumPropagationLossModel__tp_richcompare (PyNs3SpectrumPropagationLossModel *PYBINDGEN_UNUSED(self), PyNs3SpectrumPropagationLossModel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumPropagationLossModel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumPropagationLossModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumPropagationLossModel",            /* tp_name */
    sizeof(PyNs3SpectrumPropagationLossModel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumPropagationLossModel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SpectrumPropagationLossModel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SpectrumPropagationLossModel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumPropagationLossModel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumPropagationLossModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SpectrumPropagationLossModel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumPropagationLossModel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3SpectrumSignalParameters__get_duration(PyNs3SpectrumSignalParameters *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(self->obj->duration);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = Py_BuildValue((char *) "N", py_Time);
    return py_retval;
}
static int _wrap_PyNs3SpectrumSignalParameters__set_duration(PyNs3SpectrumSignalParameters *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Time *tmp_Time;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Time_Type, &tmp_Time)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->duration = *tmp_Time->obj;
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3SpectrumSignalParameters__get_psd(PyNs3SpectrumSignalParameters *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (self->obj->psd)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (self->obj->psd)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (self->obj->psd)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (self->obj->psd))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (self->obj->psd));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}
static int _wrap_PyNs3SpectrumSignalParameters__set_psd(PyNs3SpectrumSignalParameters *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        Py_DECREF(py_retval);
        return -1;
    }
    // dangerous!
    self->obj->psd = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyNs3SpectrumSignalParameters__get_txPhy(PyNs3SpectrumSignalParameters *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy)))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = reinterpret_cast< PyNs3SpectrumPhy* >(reinterpret_cast< PyNs3SpectrumPhy__PythonHelper* >(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy)))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy)))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (self->obj->txPhy));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPhy);
    return py_retval;
}
static int _wrap_PyNs3SpectrumSignalParameters__set_txPhy(PyNs3SpectrumSignalParameters *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *tmp_SpectrumPhy;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumPhy_Type, &tmp_SpectrumPhy)) {
        Py_DECREF(py_retval);
        return -1;
    }
    // dangerous!
    self->obj->txPhy = ns3::Ptr< ns3::SpectrumPhy  > (tmp_SpectrumPhy->obj);
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3SpectrumSignalParameters__getsets[] = {
    {
        (char*) "duration", /* attribute name */
        (getter) _wrap_PyNs3SpectrumSignalParameters__get_duration, /* C function to get the attribute */
        (setter) _wrap_PyNs3SpectrumSignalParameters__set_duration, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "txPhy", /* attribute name */
        (getter) _wrap_PyNs3SpectrumSignalParameters__get_txPhy, /* C function to get the attribute */
        (setter) _wrap_PyNs3SpectrumSignalParameters__set_txPhy, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "psd", /* attribute name */
        (getter) _wrap_PyNs3SpectrumSignalParameters__get_psd, /* C function to get the attribute */
        (setter) _wrap_PyNs3SpectrumSignalParameters__set_psd, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3SpectrumSignalParameters__tp_init__0(PyNs3SpectrumSignalParameters *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumSignalParameters();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumSignalParameters__tp_init__1(PyNs3SpectrumSignalParameters *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumSignalParameters *p;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &p)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumSignalParameters(*((PyNs3SpectrumSignalParameters *) p)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumSignalParameters__tp_init(PyNs3SpectrumSignalParameters *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumSignalParameters__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumSignalParameters__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumSignalParameters_Copy(PyNs3SpectrumSignalParameters *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumSignalParameters > retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->Copy();
    if (!(const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumSignalParameters);
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumSignalParameters__copy__(PyNs3SpectrumSignalParameters *self)
{

    PyNs3SpectrumSignalParameters *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumSignalParameters, &PyNs3SpectrumSignalParameters_Type);
    py_copy->obj = new ns3::SpectrumSignalParameters(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumSignalParameters_methods[] = {
    {(char *) "Copy", (PyCFunction) _wrap_PyNs3SpectrumSignalParameters_Copy, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumSignalParameters__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumSignalParameters__tp_dealloc(PyNs3SpectrumSignalParameters *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SpectrumSignalParameters *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumSignalParameters__tp_richcompare (PyNs3SpectrumSignalParameters *PYBINDGEN_UNUSED(self), PyNs3SpectrumSignalParameters *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumSignalParameters_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumSignalParameters_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumSignalParameters",            /* tp_name */
    sizeof(PyNs3SpectrumSignalParameters),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumSignalParameters__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumSignalParameters__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumSignalParameters_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3SpectrumSignalParameters__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumSignalParameters__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3SpectrumValue__tp_init__0(PyNs3SpectrumValue *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumValue *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumValue(*((PyNs3SpectrumValue *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumValue__tp_init__1(PyNs3SpectrumValue *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumModel *sm;
    ns3::SpectrumModel *sm_ptr;
    const char *keywords[] = {"sm", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumModel_Type, &sm)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    sm_ptr = (sm ? sm->obj : NULL);
    self->obj = new ns3::SpectrumValue(ns3::Ptr< ns3::SpectrumModel  > (sm_ptr));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3SpectrumValue__tp_init__2(PyNs3SpectrumValue *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::SpectrumValue();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3SpectrumValue__tp_init(PyNs3SpectrumValue *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyNs3SpectrumValue__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumValue__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyNs3SpectrumValue__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumValue_GetSpectrumModel(PyNs3SpectrumValue *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetSpectrumModel();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumValue_Copy(PyNs3SpectrumValue *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->Copy();
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumValue_GetSpectrumModelUid(PyNs3SpectrumValue *self)
{
    PyObject *py_retval;
    ns3::SpectrumModelUid_t retval;
    
    retval = self->obj->GetSpectrumModelUid();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumValue__copy__(PyNs3SpectrumValue *self)
{

    PyNs3SpectrumValue *py_copy;
    py_copy = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_copy->obj = new ns3::SpectrumValue(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumValue_methods[] = {
    {(char *) "GetSpectrumModel", (PyCFunction) _wrap_PyNs3SpectrumValue_GetSpectrumModel, METH_NOARGS, NULL },
    {(char *) "Copy", (PyCFunction) _wrap_PyNs3SpectrumValue_Copy, METH_NOARGS, NULL },
    {(char *) "GetSpectrumModelUid", (PyCFunction) _wrap_PyNs3SpectrumValue_GetSpectrumModelUid, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumValue__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3SpectrumValue__tp_dealloc(PyNs3SpectrumValue *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::SpectrumValue *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyNs3SpectrumValue__tp_str(PyNs3SpectrumValue *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyNs3SpectrumValue__tp_richcompare (PyNs3SpectrumValue *PYBINDGEN_UNUSED(self), PyNs3SpectrumValue *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumValue_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__ns3__SpectrumValue(ns3::SpectrumValue *cvalue)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(*cvalue);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


int _wrap_convert_py2c__ns3__SpectrumValue(PyObject *value, ns3::SpectrumValue *address)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_SpectrumValue->obj;
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__double(PyObject *value, double *address)
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "d", &*address)) {
        Py_DECREF(py_retval);
        return 0;
    }
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(PyObject *value, ns3::SpectrumValue *address)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_SpectrumValue->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
Ns3SpectrumValue__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left + right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left + right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left - right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left - right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left * right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left * right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left / right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left / right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left += right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left += right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left -= right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left -= right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_inplace_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left *= right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left *= right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_inplace_divide (PyObject *py_left, PyObject *py_right)
{
    {
        ns3::SpectrumValue left;
        ns3::SpectrumValue right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__ns3__SpectrumValue_const___amp__(py_right, &right)) {
            ns3::SpectrumValue result = (left /= right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    {
        ns3::SpectrumValue left;
        double right;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            ns3::SpectrumValue result = (left /= right);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
Ns3SpectrumValue__nb_negative (PyObject *py_self)
{
    {
        ns3::SpectrumValue self;
        if (_wrap_convert_py2c__ns3__SpectrumValue(py_self, &self)) {
            ns3::SpectrumValue result = -(self);
            return _wrap_convert_c2py__ns3__SpectrumValue(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods Ns3SpectrumValue__py_number_methods = {
    (binaryfunc) Ns3SpectrumValue__nb_add,
    (binaryfunc) Ns3SpectrumValue__nb_subtract,
    (binaryfunc) Ns3SpectrumValue__nb_multiply,
    (binaryfunc) Ns3SpectrumValue__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) Ns3SpectrumValue__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) Ns3SpectrumValue__nb_inplace_add,
    (binaryfunc) Ns3SpectrumValue__nb_inplace_subtract,
    (binaryfunc) Ns3SpectrumValue__nb_inplace_multiply,
    (binaryfunc) Ns3SpectrumValue__nb_inplace_divide,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};

PyTypeObject PyNs3SpectrumValue_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumValue",            /* tp_name */
    sizeof(PyNs3SpectrumValue),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumValue__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&Ns3SpectrumValue__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyNs3SpectrumValue__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumValue__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumValue_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumValue__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_GetRxSpectrumModel(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetRxSpectrumModel of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetRxSpectrumModel__parent_caller();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_SetMobility(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetMobility of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetMobility__parent_caller(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_NotifyNewAggregate(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_GetInstanceTypeId(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_Stop(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method Stop of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    helper->Stop__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_DoStart(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_Start(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method Start of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    helper->Start__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_SetChannel(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetChannel of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetChannel__parent_caller(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_StartRx(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method StartRx of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    helper->StartRx__parent_caller(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_SetDevice(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetDevice of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetDevice__parent_caller(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_GetMobility(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMobility of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetMobility__parent_caller();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}

PyObject *
PyNs3WaveformGenerator__PythonHelper::_wrap_GetDevice(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3WaveformGenerator__PythonHelper *helper = dynamic_cast< PyNs3WaveformGenerator__PythonHelper* >(self->obj);
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetDevice of class WaveformGenerator is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetDevice__parent_caller();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3WaveformGenerator__PythonHelper::GetDevice()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetDevice();
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetDevice();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetDevice();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::MobilityModel >
PyNs3WaveformGenerator__PythonHelper::GetMobility()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *tmp_MobilityModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetMobility();
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMobility", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetMobility();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3MobilityModel_Type, &tmp_MobilityModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetMobility();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::MobilityModel  > (tmp_MobilityModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumModel const >
PyNs3WaveformGenerator__PythonHelper::GetRxSpectrumModel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *tmp_SpectrumModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetRxSpectrumModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetRxSpectrumModel();
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = const_cast< ns3::WaveformGenerator* >((const ns3::WaveformGenerator*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetRxSpectrumModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetRxSpectrumModel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumModel_Type, &tmp_SpectrumModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::WaveformGenerator::GetRxSpectrumModel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumModel  > (tmp_SpectrumModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3WaveformGenerator__PythonHelper::SetChannel(ns3::Ptr< ns3::SpectrumChannel > c)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumChannel *py_SpectrumChannel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::WaveformGenerator::SetChannel(c);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    if (typeid(*(const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))).name() == typeid(PyNs3SpectrumChannel__PythonHelper).name())
    {
        py_SpectrumChannel = (PyNs3SpectrumChannel*) (((PyNs3SpectrumChannel__PythonHelper*) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))->m_pyself);
        py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
        Py_INCREF(py_SpectrumChannel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumChannel = NULL;
        } else {
            py_SpectrumChannel = (PyNs3SpectrumChannel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumChannel);
        }
    
        if (py_SpectrumChannel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))), &PyNs3SpectrumChannel_Type);
            py_SpectrumChannel = PyObject_GC_New(PyNs3SpectrumChannel, wrapper_type);
            py_SpectrumChannel->inst_dict = NULL;
            py_SpectrumChannel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))->Ref();
            py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumChannel->obj] = (PyObject *) py_SpectrumChannel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetChannel", (char *) "N", py_SpectrumChannel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::SetDevice(ns3::Ptr< ns3::NetDevice > d)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::WaveformGenerator::SetDevice(d);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::SetMobility(ns3::Ptr< ns3::MobilityModel > m)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::WaveformGenerator::SetMobility(m);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetMobility", (char *) "N", py_MobilityModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::Start()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_Start"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::WaveformGenerator::Start();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_Start", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::StartRx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::WaveformGenerator::StartRx(params);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::Stop()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_Stop"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::WaveformGenerator::Stop();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_Stop", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::GenerateWaveform()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::WaveformGenerator *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GenerateWaveform"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj;
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = (ns3::WaveformGenerator*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GenerateWaveform", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3WaveformGenerator* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3WaveformGenerator__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3WaveformGenerator__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3WaveformGenerator__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3WaveformGenerator__tp_init__0(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3WaveformGenerator *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3WaveformGenerator_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3WaveformGenerator_Type)
    {
        self->obj = new PyNs3WaveformGenerator__PythonHelper(*((PyNs3WaveformGenerator *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3WaveformGenerator__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::WaveformGenerator(*((PyNs3WaveformGenerator *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3WaveformGenerator__tp_init__1(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3WaveformGenerator_Type)
    {
        self->obj = new PyNs3WaveformGenerator__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3WaveformGenerator__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::WaveformGenerator();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3WaveformGenerator__tp_init(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3WaveformGenerator__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3WaveformGenerator__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3WaveformGenerator_GetRxSpectrumModel(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRxSpectrumModel();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_SetPeriod(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Time *period;
    const char *keywords[] = {"period", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Time_Type, &period)) {
        return NULL;
    }
    self->obj->SetPeriod(*((PyNs3Time *) period)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_SetMobility(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->SetMobility(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::WaveformGenerator::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_Stop(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    
    self->obj->Stop();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_Start(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    
    self->obj->Start();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_SetChannel(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_SetTxPowerSpectralDensity(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *txs;
    ns3::SpectrumValue *txs_ptr;
    const char *keywords[] = {"txs", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txs)) {
        return NULL;
    }
    txs_ptr = (txs ? txs->obj : NULL);
    self->obj->SetTxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (txs_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_StartRx(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_GetDutyCycle(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    double retval;
    
    retval = self->obj->GetDutyCycle();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_SetDevice(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_GetMobility(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetMobility();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_SetDutyCycle(PyNs3WaveformGenerator *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double value;
    const char *keywords[] = {"value", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "d", (char **) keywords, &value)) {
        return NULL;
    }
    self->obj->SetDutyCycle(value);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_GetDevice(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3WaveformGenerator_GetPeriod(PyNs3WaveformGenerator *self)
{
    PyObject *py_retval;
    PyNs3Time *py_Time;
    
    ns3::Time retval = self->obj->GetPeriod();
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(retval);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = Py_BuildValue((char *) "N", py_Time);
    return py_retval;
}


static PyObject*
_wrap_PyNs3WaveformGenerator__copy__(PyNs3WaveformGenerator *self)
{

    PyNs3WaveformGenerator *py_copy;
    py_copy = PyObject_GC_New(PyNs3WaveformGenerator, &PyNs3WaveformGenerator_Type);
    py_copy->obj = new ns3::WaveformGenerator(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3WaveformGenerator_methods[] = {
    {(char *) "GetRxSpectrumModel", (PyCFunction) _wrap_PyNs3WaveformGenerator_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "SetPeriod", (PyCFunction) _wrap_PyNs3WaveformGenerator_SetPeriod, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMobility", (PyCFunction) _wrap_PyNs3WaveformGenerator_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3WaveformGenerator_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Stop", (PyCFunction) _wrap_PyNs3WaveformGenerator_Stop, METH_NOARGS, NULL },
    {(char *) "Start", (PyCFunction) _wrap_PyNs3WaveformGenerator_Start, METH_NOARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3WaveformGenerator_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetTxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3WaveformGenerator_SetTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3WaveformGenerator_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDutyCycle", (PyCFunction) _wrap_PyNs3WaveformGenerator_GetDutyCycle, METH_NOARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3WaveformGenerator_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMobility", (PyCFunction) _wrap_PyNs3WaveformGenerator_GetMobility, METH_NOARGS, NULL },
    {(char *) "SetDutyCycle", (PyCFunction) _wrap_PyNs3WaveformGenerator_SetDutyCycle, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3WaveformGenerator_GetDevice, METH_NOARGS, NULL },
    {(char *) "GetPeriod", (PyCFunction) _wrap_PyNs3WaveformGenerator_GetPeriod, METH_NOARGS, NULL },
    {(char *) "_GetRxSpectrumModel", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_SetMobility", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_Stop", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_Stop, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_Start", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_Start, METH_NOARGS, NULL },
    {(char *) "_SetChannel", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_StartRx", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetDevice", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetMobility", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_GetMobility, METH_NOARGS, NULL },
    {(char *) "_GetDevice", (PyCFunction) PyNs3WaveformGenerator__PythonHelper::_wrap_GetDevice, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3WaveformGenerator__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3WaveformGenerator__tp_clear(PyNs3WaveformGenerator *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::WaveformGenerator *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3WaveformGenerator__tp_traverse(PyNs3WaveformGenerator *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3WaveformGenerator__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3WaveformGenerator__tp_dealloc(PyNs3WaveformGenerator *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3WaveformGenerator__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3WaveformGenerator__tp_richcompare (PyNs3WaveformGenerator *PYBINDGEN_UNUSED(self), PyNs3WaveformGenerator *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3WaveformGenerator_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3WaveformGenerator_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.WaveformGenerator",            /* tp_name */
    sizeof(PyNs3WaveformGenerator),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3WaveformGenerator__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3WaveformGenerator__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3WaveformGenerator__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3WaveformGenerator__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3WaveformGenerator_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3WaveformGenerator, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3WaveformGenerator__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyNs3AlohaNoackMacHeader__tp_init__0(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::AlohaNoackMacHeader();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3AlohaNoackMacHeader__tp_init__1(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3AlohaNoackMacHeader *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3AlohaNoackMacHeader_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::AlohaNoackMacHeader(*((PyNs3AlohaNoackMacHeader *) arg0)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3AlohaNoackMacHeader__tp_init(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AlohaNoackMacHeader__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AlohaNoackMacHeader__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_Deserialize(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    retval = self->obj->Deserialize(*((PyNs3BufferIterator *) start)->obj);
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::AlohaNoackMacHeader::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_Serialize(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3BufferIterator *start;
    const char *keywords[] = {"start", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3BufferIterator_Type, &start)) {
        return NULL;
    }
    self->obj->Serialize(*((PyNs3BufferIterator *) start)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_SetDestination(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Mac48Address *destination;
    const char *keywords[] = {"destination", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Mac48Address_Type, &destination)) {
        return NULL;
    }
    self->obj->SetDestination(*((PyNs3Mac48Address *) destination)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_GetInstanceTypeId(PyNs3AlohaNoackMacHeader *self)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = self->obj->GetInstanceTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_GetSerializedSize(PyNs3AlohaNoackMacHeader *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetSerializedSize();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_GetDestination(PyNs3AlohaNoackMacHeader *self)
{
    PyObject *py_retval;
    PyNs3Mac48Address *py_Mac48Address;
    
    ns3::Mac48Address retval = self->obj->GetDestination();
    py_Mac48Address = PyObject_New(PyNs3Mac48Address, &PyNs3Mac48Address_Type);
    py_Mac48Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Mac48Address->obj = new ns3::Mac48Address(retval);
    PyNs3Mac48Address_wrapper_registry[(void *) py_Mac48Address->obj] = (PyObject *) py_Mac48Address;
    py_retval = Py_BuildValue((char *) "N", py_Mac48Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_GetSource(PyNs3AlohaNoackMacHeader *self)
{
    PyObject *py_retval;
    PyNs3Mac48Address *py_Mac48Address;
    
    ns3::Mac48Address retval = self->obj->GetSource();
    py_Mac48Address = PyObject_New(PyNs3Mac48Address, &PyNs3Mac48Address_Type);
    py_Mac48Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Mac48Address->obj = new ns3::Mac48Address(retval);
    PyNs3Mac48Address_wrapper_registry[(void *) py_Mac48Address->obj] = (PyObject *) py_Mac48Address;
    py_retval = Py_BuildValue((char *) "N", py_Mac48Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackMacHeader_SetSource(PyNs3AlohaNoackMacHeader *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Mac48Address *source;
    const char *keywords[] = {"source", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Mac48Address_Type, &source)) {
        return NULL;
    }
    self->obj->SetSource(*((PyNs3Mac48Address *) source)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3AlohaNoackMacHeader__copy__(PyNs3AlohaNoackMacHeader *self)
{

    PyNs3AlohaNoackMacHeader *py_copy;
    py_copy = PyObject_GC_New(PyNs3AlohaNoackMacHeader, &PyNs3AlohaNoackMacHeader_Type);
    py_copy->obj = new ns3::AlohaNoackMacHeader(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3AlohaNoackMacHeader_methods[] = {
    {(char *) "Deserialize", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_Deserialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Serialize", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_Serialize, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDestination", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_SetDestination, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetInstanceTypeId", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "GetSerializedSize", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_GetSerializedSize, METH_NOARGS, NULL },
    {(char *) "GetDestination", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_GetDestination, METH_NOARGS, NULL },
    {(char *) "GetSource", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_GetSource, METH_NOARGS, NULL },
    {(char *) "SetSource", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader_SetSource, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3AlohaNoackMacHeader__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3AlohaNoackMacHeader__tp_clear(PyNs3AlohaNoackMacHeader *self)
{
    Py_CLEAR(self->inst_dict);
        ns3::AlohaNoackMacHeader *tmp = self->obj;
    self->obj = NULL;
    if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
        delete tmp;
    }
}


static int
PyNs3AlohaNoackMacHeader__tp_traverse(PyNs3AlohaNoackMacHeader *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    return 0;
}


static void
_wrap_PyNs3AlohaNoackMacHeader__tp_dealloc(PyNs3AlohaNoackMacHeader *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3AlohaNoackMacHeader__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3AlohaNoackMacHeader__tp_richcompare (PyNs3AlohaNoackMacHeader *PYBINDGEN_UNUSED(self), PyNs3AlohaNoackMacHeader *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3AlohaNoackMacHeader_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3AlohaNoackMacHeader_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.AlohaNoackMacHeader",            /* tp_name */
    sizeof(PyNs3AlohaNoackMacHeader),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3AlohaNoackMacHeader__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3AlohaNoackMacHeader__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3AlohaNoackMacHeader__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3AlohaNoackMacHeader__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3AlohaNoackMacHeader_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3AlohaNoackMacHeader, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3AlohaNoackMacHeader__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3FriisSpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3FriisSpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3FriisSpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3FriisSpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3FriisSpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3FriisSpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_DoDispose(PyNs3FriisSpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3FriisSpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3FriisSpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class SpectrumPropagationLossModel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_DoStart(PyNs3FriisSpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3FriisSpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3FriisSpectrumPropagationLossModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_DoCalcRxPowerSpectralDensity(PyNs3FriisSpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *txPsd;
    ns3::SpectrumValue *txPsd_ptr;
    PyNs3MobilityModel *a;
    ns3::MobilityModel *a_ptr;
    PyNs3MobilityModel *b;
    ns3::MobilityModel *b_ptr;
    PyNs3FriisSpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3FriisSpectrumPropagationLossModel__PythonHelper* >(self->obj);
    const char *keywords[] = {"txPsd", "a", "b", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txPsd, &PyNs3MobilityModel_Type, &a, &PyNs3MobilityModel_Type, &b)) {
        return NULL;
    }
    txPsd_ptr = (txPsd ? txPsd->obj : NULL);
    a_ptr = (a ? a->obj : NULL);
    b_ptr = (b ? b->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoCalcRxPowerSpectralDensity of class FriisSpectrumPropagationLossModel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->DoCalcRxPowerSpectralDensity__parent_caller(ns3::Ptr< ns3::SpectrumValue  > (txPsd_ptr), ns3::Ptr< ns3::MobilityModel  > (a_ptr), ns3::Ptr< ns3::MobilityModel  > (b_ptr));
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}

PyObject *
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3FriisSpectrumPropagationLossModel *self)
{
    PyObject *py_retval;
    PyNs3FriisSpectrumPropagationLossModel__PythonHelper *helper = dynamic_cast< PyNs3FriisSpectrumPropagationLossModel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

ns3::Ptr< ns3::SpectrumValue >
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::DoCalcRxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue const > txPsd, ns3::Ptr< ns3::MobilityModel const > a, ns3::Ptr< ns3::MobilityModel const > b) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::FriisSpectrumPropagationLossModel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    PyNs3MobilityModel *py_MobilityModel2;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter3;
    PyTypeObject *wrapper_type3 = 0;
    PyNs3SpectrumValue *tmp_SpectrumValue;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoCalcRxPowerSpectralDensity"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::FriisSpectrumPropagationLossModel::DoCalcRxPowerSpectralDensity(txPsd, a, b);
    }
    self_obj_before = reinterpret_cast< PyNs3FriisSpectrumPropagationLossModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3FriisSpectrumPropagationLossModel* >(m_pyself)->obj = const_cast< ns3::FriisSpectrumPropagationLossModel* >((const ns3::FriisSpectrumPropagationLossModel*) this);
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (txPsd));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter2->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type2);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (a));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel2 = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b)))->m_pyself);
        py_MobilityModel2->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b));
        Py_INCREF(py_MobilityModel2);
    } else {
        wrapper_lookup_iter3 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b)));
        if (wrapper_lookup_iter3 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel2 = NULL;
        } else {
            py_MobilityModel2 = (PyNs3MobilityModel *) wrapper_lookup_iter3->second;
            Py_INCREF(py_MobilityModel2);
        }
    
        if (py_MobilityModel2 == NULL)
        {
            wrapper_type3 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b))), &PyNs3MobilityModel_Type);
            py_MobilityModel2 = PyObject_GC_New(PyNs3MobilityModel, wrapper_type3);
            py_MobilityModel2->inst_dict = NULL;
            py_MobilityModel2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b))->Ref();
            py_MobilityModel2->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (b));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel2->obj] = (PyObject *) py_MobilityModel2;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoCalcRxPowerSpectralDensity", (char *) "NNN", py_SpectrumValue, py_MobilityModel, py_MobilityModel2);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3FriisSpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::FriisSpectrumPropagationLossModel::DoCalcRxPowerSpectralDensity(txPsd, a, b);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumValue_Type, &tmp_SpectrumValue)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3FriisSpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::FriisSpectrumPropagationLossModel::DoCalcRxPowerSpectralDensity(txPsd, a, b);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumValue  > (tmp_SpectrumValue->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3FriisSpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumPropagationLossModel *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumPropagationLossModel::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = (ns3::SpectrumPropagationLossModel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3FriisSpectrumPropagationLossModel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_init__0(PyNs3FriisSpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3FriisSpectrumPropagationLossModel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3FriisSpectrumPropagationLossModel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3FriisSpectrumPropagationLossModel_Type)
    {
        self->obj = new PyNs3FriisSpectrumPropagationLossModel__PythonHelper(*((PyNs3FriisSpectrumPropagationLossModel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3FriisSpectrumPropagationLossModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::FriisSpectrumPropagationLossModel(*((PyNs3FriisSpectrumPropagationLossModel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_init__1(PyNs3FriisSpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3FriisSpectrumPropagationLossModel_Type)
    {
        self->obj = new PyNs3FriisSpectrumPropagationLossModel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3FriisSpectrumPropagationLossModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::FriisSpectrumPropagationLossModel();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3FriisSpectrumPropagationLossModel__tp_init(PyNs3FriisSpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3FriisSpectrumPropagationLossModel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3FriisSpectrumPropagationLossModel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3FriisSpectrumPropagationLossModel_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::FriisSpectrumPropagationLossModel::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3FriisSpectrumPropagationLossModel_DoCalcRxPowerSpectralDensity(PyNs3FriisSpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumValue > retval;
    PyNs3SpectrumValue *txPsd;
    ns3::SpectrumValue *txPsd_ptr;
    PyNs3MobilityModel *a;
    ns3::MobilityModel *a_ptr;
    PyNs3MobilityModel *b;
    ns3::MobilityModel *b_ptr;
    const char *keywords[] = {"txPsd", "a", "b", NULL};
    PyNs3SpectrumValue *py_SpectrumValue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txPsd, &PyNs3MobilityModel_Type, &a, &PyNs3MobilityModel_Type, &b)) {
        return NULL;
    }
    txPsd_ptr = (txPsd ? txPsd->obj : NULL);
    a_ptr = (a ? a->obj : NULL);
    b_ptr = (b ? b->obj : NULL);
    retval = self->obj->DoCalcRxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (txPsd_ptr), ns3::Ptr< ns3::MobilityModel  > (a_ptr), ns3::Ptr< ns3::MobilityModel  > (b_ptr));
    if (!(const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumValue = NULL;
    } else {
        py_SpectrumValue = (PyNs3SpectrumValue *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumValue);
    }
    
    if (py_SpectrumValue == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumValue_Type);
        py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, wrapper_type);
        py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumValue->obj = const_cast<ns3::SpectrumValue *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumValue);
    return py_retval;
}


PyObject *
_wrap_PyNs3FriisSpectrumPropagationLossModel_CalculateLoss(PyNs3FriisSpectrumPropagationLossModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    double f;
    double d;
    const char *keywords[] = {"f", "d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dd", (char **) keywords, &f, &d)) {
        return NULL;
    }
    retval = self->obj->CalculateLoss(f, d);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


static PyObject*
_wrap_PyNs3FriisSpectrumPropagationLossModel__copy__(PyNs3FriisSpectrumPropagationLossModel *self)
{

    PyNs3FriisSpectrumPropagationLossModel *py_copy;
    py_copy = PyObject_GC_New(PyNs3FriisSpectrumPropagationLossModel, &PyNs3FriisSpectrumPropagationLossModel_Type);
    py_copy->obj = new ns3::FriisSpectrumPropagationLossModel(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3FriisSpectrumPropagationLossModel_methods[] = {
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3FriisSpectrumPropagationLossModel_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "DoCalcRxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3FriisSpectrumPropagationLossModel_DoCalcRxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "CalculateLoss", (PyCFunction) _wrap_PyNs3FriisSpectrumPropagationLossModel_CalculateLoss, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_DoCalcRxPowerSpectralDensity", (PyCFunction) PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_DoCalcRxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3FriisSpectrumPropagationLossModel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3FriisSpectrumPropagationLossModel__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3FriisSpectrumPropagationLossModel__tp_clear(PyNs3FriisSpectrumPropagationLossModel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::FriisSpectrumPropagationLossModel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3FriisSpectrumPropagationLossModel__tp_traverse(PyNs3FriisSpectrumPropagationLossModel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3FriisSpectrumPropagationLossModel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_dealloc(PyNs3FriisSpectrumPropagationLossModel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3FriisSpectrumPropagationLossModel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_richcompare (PyNs3FriisSpectrumPropagationLossModel *PYBINDGEN_UNUSED(self), PyNs3FriisSpectrumPropagationLossModel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3FriisSpectrumPropagationLossModel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3FriisSpectrumPropagationLossModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.FriisSpectrumPropagationLossModel",            /* tp_name */
    sizeof(PyNs3FriisSpectrumPropagationLossModel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3FriisSpectrumPropagationLossModel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3FriisSpectrumPropagationLossModel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3FriisSpectrumPropagationLossModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3FriisSpectrumPropagationLossModel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3FriisSpectrumPropagationLossModel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetRxSpectrumModel(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetRxSpectrumModel of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetRxSpectrumModel__parent_caller();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_SetMobility(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetMobility of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetMobility__parent_caller(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_NotifyNewAggregate(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetInstanceTypeId(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_DoStart(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_SetChannel(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetChannel of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetChannel__parent_caller(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_StartRx(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method StartRx of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    helper->StartRx__parent_caller(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_SetDevice(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetDevice of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetDevice__parent_caller(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetMobility(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMobility of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetMobility__parent_caller();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}

PyObject *
PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetDevice(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3HalfDuplexIdealPhy__PythonHelper *helper = dynamic_cast< PyNs3HalfDuplexIdealPhy__PythonHelper* >(self->obj);
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetDevice of class HalfDuplexIdealPhy is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetDevice__parent_caller();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3HalfDuplexIdealPhy__PythonHelper::GetDevice()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetDevice();
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetDevice();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetDevice();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::MobilityModel >
PyNs3HalfDuplexIdealPhy__PythonHelper::GetMobility()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *tmp_MobilityModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetMobility();
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMobility", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetMobility();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3MobilityModel_Type, &tmp_MobilityModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetMobility();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::MobilityModel  > (tmp_MobilityModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumModel const >
PyNs3HalfDuplexIdealPhy__PythonHelper::GetRxSpectrumModel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *tmp_SpectrumModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetRxSpectrumModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetRxSpectrumModel();
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = const_cast< ns3::HalfDuplexIdealPhy* >((const ns3::HalfDuplexIdealPhy*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetRxSpectrumModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetRxSpectrumModel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumModel_Type, &tmp_SpectrumModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::HalfDuplexIdealPhy::GetRxSpectrumModel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumModel  > (tmp_SpectrumModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::SetChannel(ns3::Ptr< ns3::SpectrumChannel > c)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumChannel *py_SpectrumChannel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::HalfDuplexIdealPhy::SetChannel(c);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    if (typeid(*(const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))).name() == typeid(PyNs3SpectrumChannel__PythonHelper).name())
    {
        py_SpectrumChannel = (PyNs3SpectrumChannel*) (((PyNs3SpectrumChannel__PythonHelper*) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))->m_pyself);
        py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
        Py_INCREF(py_SpectrumChannel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumChannel = NULL;
        } else {
            py_SpectrumChannel = (PyNs3SpectrumChannel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumChannel);
        }
    
        if (py_SpectrumChannel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))), &PyNs3SpectrumChannel_Type);
            py_SpectrumChannel = PyObject_GC_New(PyNs3SpectrumChannel, wrapper_type);
            py_SpectrumChannel->inst_dict = NULL;
            py_SpectrumChannel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))->Ref();
            py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumChannel->obj] = (PyObject *) py_SpectrumChannel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetChannel", (char *) "N", py_SpectrumChannel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::SetDevice(ns3::Ptr< ns3::NetDevice > d)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::HalfDuplexIdealPhy::SetDevice(d);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::SetMobility(ns3::Ptr< ns3::MobilityModel > m)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::HalfDuplexIdealPhy::SetMobility(m);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetMobility", (char *) "N", py_MobilityModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::StartRx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::HalfDuplexIdealPhy::StartRx(params);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::HalfDuplexIdealPhy *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj;
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = (ns3::HalfDuplexIdealPhy*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3HalfDuplexIdealPhy* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3HalfDuplexIdealPhy__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3HalfDuplexIdealPhy__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3HalfDuplexIdealPhy__tp_init__0(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3HalfDuplexIdealPhy *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3HalfDuplexIdealPhy_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3HalfDuplexIdealPhy_Type)
    {
        self->obj = new PyNs3HalfDuplexIdealPhy__PythonHelper(*((PyNs3HalfDuplexIdealPhy *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3HalfDuplexIdealPhy__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::HalfDuplexIdealPhy(*((PyNs3HalfDuplexIdealPhy *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3HalfDuplexIdealPhy__tp_init__1(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3HalfDuplexIdealPhy_Type)
    {
        self->obj = new PyNs3HalfDuplexIdealPhy__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3HalfDuplexIdealPhy__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::HalfDuplexIdealPhy();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3HalfDuplexIdealPhy__tp_init(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3HalfDuplexIdealPhy__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3HalfDuplexIdealPhy__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_GetRxSpectrumModel(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRxSpectrumModel();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyRxEndErrorCallback(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *c;
    ns3::Ptr<PythonCallbackImpl1> c_cb_impl;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &c)) {
        return NULL;
    }
    if (!PyCallable_Check(c)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'c' must be callbale");
        return NULL;
    }
    c_cb_impl = ns3::Create<PythonCallbackImpl1> (c);
    self->obj->SetGenericPhyRxEndErrorCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (c_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetMobility(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->SetMobility(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_StartTx(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    retval = self->obj->StartTx(ns3::Ptr< ns3::Packet  > (p_ptr));
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyTxEndCallback(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *c;
    ns3::Ptr<PythonCallbackImpl2> c_cb_impl;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &c)) {
        return NULL;
    }
    if (!PyCallable_Check(c)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'c' must be callbale");
        return NULL;
    }
    c_cb_impl = ns3::Create<PythonCallbackImpl2> (c);
    self->obj->SetGenericPhyTxEndCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet const>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (c_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::HalfDuplexIdealPhy::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_GetRate(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    PyNs3DataRate *py_DataRate;
    
    ns3::DataRate retval = self->obj->GetRate();
    py_DataRate = PyObject_New(PyNs3DataRate, &PyNs3DataRate_Type);
    py_DataRate->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_DataRate->obj = new ns3::DataRate(retval);
    PyNs3DataRate_wrapper_registry[(void *) py_DataRate->obj] = (PyObject *) py_DataRate;
    py_retval = Py_BuildValue((char *) "N", py_DataRate);
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetRate(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3DataRate *rate;
    const char *keywords[] = {"rate", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3DataRate_Type, &rate)) {
        return NULL;
    }
    self->obj->SetRate(*((PyNs3DataRate *) rate)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetChannel(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetTxPowerSpectralDensity(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *txPsd;
    ns3::SpectrumValue *txPsd_ptr;
    const char *keywords[] = {"txPsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &txPsd)) {
        return NULL;
    }
    txPsd_ptr = (txPsd ? txPsd->obj : NULL);
    self->obj->SetTxPowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (txPsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_StartRx(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyRxEndOkCallback(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *c;
    ns3::Ptr<PythonCallbackImpl0> c_cb_impl;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &c)) {
        return NULL;
    }
    if (!PyCallable_Check(c)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'c' must be callbale");
        return NULL;
    }
    c_cb_impl = ns3::Create<PythonCallbackImpl0> (c);
    self->obj->SetGenericPhyRxEndOkCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (c_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetDevice(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_GetMobility(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetMobility();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetNoisePowerSpectralDensity(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *noisePsd;
    ns3::SpectrumValue *noisePsd_ptr;
    const char *keywords[] = {"noisePsd", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumValue_Type, &noisePsd)) {
        return NULL;
    }
    noisePsd_ptr = (noisePsd ? noisePsd->obj : NULL);
    self->obj->SetNoisePowerSpectralDensity(ns3::Ptr< ns3::SpectrumValue  > (noisePsd_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_GetDevice(PyNs3HalfDuplexIdealPhy *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyRxStartCallback(PyNs3HalfDuplexIdealPhy *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *c;
    ns3::Ptr<PythonCallbackImpl1> c_cb_impl;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &c)) {
        return NULL;
    }
    if (!PyCallable_Check(c)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'c' must be callbale");
        return NULL;
    }
    c_cb_impl = ns3::Create<PythonCallbackImpl1> (c);
    self->obj->SetGenericPhyRxStartCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (c_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3HalfDuplexIdealPhy__copy__(PyNs3HalfDuplexIdealPhy *self)
{

    PyNs3HalfDuplexIdealPhy *py_copy;
    py_copy = PyObject_GC_New(PyNs3HalfDuplexIdealPhy, &PyNs3HalfDuplexIdealPhy_Type);
    py_copy->obj = new ns3::HalfDuplexIdealPhy(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3HalfDuplexIdealPhy_methods[] = {
    {(char *) "GetRxSpectrumModel", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "SetGenericPhyRxEndErrorCallback", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyRxEndErrorCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetMobility", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartTx", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_StartTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetGenericPhyTxEndCallback", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyTxEndCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetRate", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_GetRate, METH_NOARGS, NULL },
    {(char *) "SetRate", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetRate, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetTxPowerSpectralDensity", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetTxPowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetGenericPhyRxEndOkCallback", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyRxEndOkCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMobility", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_GetMobility, METH_NOARGS, NULL },
    {(char *) "SetNoisePowerSpectralDensity", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetNoisePowerSpectralDensity, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_GetDevice, METH_NOARGS, NULL },
    {(char *) "SetGenericPhyRxStartCallback", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy_SetGenericPhyRxStartCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetRxSpectrumModel", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_SetMobility", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_SetChannel", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_StartRx", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetDevice", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetMobility", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetMobility, METH_NOARGS, NULL },
    {(char *) "_GetDevice", (PyCFunction) PyNs3HalfDuplexIdealPhy__PythonHelper::_wrap_GetDevice, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhy__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3HalfDuplexIdealPhy__tp_clear(PyNs3HalfDuplexIdealPhy *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::HalfDuplexIdealPhy *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3HalfDuplexIdealPhy__tp_traverse(PyNs3HalfDuplexIdealPhy *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3HalfDuplexIdealPhy__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3HalfDuplexIdealPhy__tp_dealloc(PyNs3HalfDuplexIdealPhy *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3HalfDuplexIdealPhy__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3HalfDuplexIdealPhy__tp_richcompare (PyNs3HalfDuplexIdealPhy *PYBINDGEN_UNUSED(self), PyNs3HalfDuplexIdealPhy *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3HalfDuplexIdealPhy_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3HalfDuplexIdealPhy_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.HalfDuplexIdealPhy",            /* tp_name */
    sizeof(PyNs3HalfDuplexIdealPhy),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3HalfDuplexIdealPhy__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3HalfDuplexIdealPhy__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3HalfDuplexIdealPhy__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3HalfDuplexIdealPhy__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3HalfDuplexIdealPhy_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3HalfDuplexIdealPhy, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3HalfDuplexIdealPhy__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};



static PyObject* _wrap_PyNs3HalfDuplexIdealPhySignalParameters__get_data(PyNs3HalfDuplexIdealPhySignalParameters *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!(const_cast<ns3::Packet *> (ns3::PeekPointer (self->obj->data)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (self->obj->data)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Packet *> (ns3::PeekPointer (self->obj->data)))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (self->obj->data))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (self->obj->data));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = Py_BuildValue((char *) "N", py_Packet);
    return py_retval;
}
static int _wrap_PyNs3HalfDuplexIdealPhySignalParameters__set_data(PyNs3HalfDuplexIdealPhySignalParameters *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    PyNs3Packet *tmp_Packet;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Packet_Type, &tmp_Packet)) {
        Py_DECREF(py_retval);
        return -1;
    }
    // dangerous!
    self->obj->data = ns3::Ptr< ns3::Packet  > (tmp_Packet->obj);
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyNs3HalfDuplexIdealPhySignalParameters__getsets[] = {
    {
        (char*) "data", /* attribute name */
        (getter) _wrap_PyNs3HalfDuplexIdealPhySignalParameters__get_data, /* C function to get the attribute */
        (setter) _wrap_PyNs3HalfDuplexIdealPhySignalParameters__set_data, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_init__0(PyNs3HalfDuplexIdealPhySignalParameters *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::HalfDuplexIdealPhySignalParameters();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_init__1(PyNs3HalfDuplexIdealPhySignalParameters *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3HalfDuplexIdealPhySignalParameters *p;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3HalfDuplexIdealPhySignalParameters_Type, &p)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ns3::HalfDuplexIdealPhySignalParameters(*((PyNs3HalfDuplexIdealPhySignalParameters *) p)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_init(PyNs3HalfDuplexIdealPhySignalParameters *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3HalfDuplexIdealPhySignalParameters_Copy(PyNs3HalfDuplexIdealPhySignalParameters *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumSignalParameters > retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->Copy();
    if (!(const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumSignalParameters);
    return py_retval;
}


static PyObject*
_wrap_PyNs3HalfDuplexIdealPhySignalParameters__copy__(PyNs3HalfDuplexIdealPhySignalParameters *self)
{

    PyNs3HalfDuplexIdealPhySignalParameters *py_copy;
    py_copy = PyObject_New(PyNs3HalfDuplexIdealPhySignalParameters, &PyNs3HalfDuplexIdealPhySignalParameters_Type);
    py_copy->obj = new ns3::HalfDuplexIdealPhySignalParameters(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3Empty_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3HalfDuplexIdealPhySignalParameters_methods[] = {
    {(char *) "Copy", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhySignalParameters_Copy, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3HalfDuplexIdealPhySignalParameters__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_dealloc(PyNs3HalfDuplexIdealPhySignalParameters *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3Empty_wrapper_registry.end()) {
        PyNs3Empty_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    if (self->obj) {
        ns3::HalfDuplexIdealPhySignalParameters *tmp = self->obj;
        self->obj = NULL;
        tmp->Unref();
    }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_richcompare (PyNs3HalfDuplexIdealPhySignalParameters *PYBINDGEN_UNUSED(self), PyNs3HalfDuplexIdealPhySignalParameters *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3HalfDuplexIdealPhySignalParameters_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3HalfDuplexIdealPhySignalParameters_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.HalfDuplexIdealPhySignalParameters",            /* tp_name */
    sizeof(PyNs3HalfDuplexIdealPhySignalParameters),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3HalfDuplexIdealPhySignalParameters_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyNs3HalfDuplexIdealPhySignalParameters__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3HalfDuplexIdealPhySignalParameters__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMulticast__0(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMulticast of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = helper->GetMulticast__parent_caller(*((PyNs3Ipv4Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMulticast__1(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *addr;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMulticast of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = helper->GetMulticast__parent_caller(*((PyNs3Ipv6Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject * PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMulticast(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMulticast__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMulticast__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsPointToPoint(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsPointToPoint of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsPointToPoint__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_Send(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"packet", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!Oi", (char **) keywords, &PyNs3Packet_Type, &packet, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method Send of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->Send__parent_caller(ns3::Ptr< ns3::Packet  > (packet_ptr), dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetIfIndex(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetIfIndex of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetIfIndex__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_NeedsArp(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NeedsArp of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->NeedsArp__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetPromiscReceiveCallback(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl4> cb_cb_impl;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl4> (cb);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetPromiscReceiveCallback of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetPromiscReceiveCallback__parent_caller(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::Address const&, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetNode(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetNode of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetNode__parent_caller();
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SendFrom(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *source;
    ns3::Address source2;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"packet", "source", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!OOi", (char **) keywords, &PyNs3Packet_Type, &packet, &source, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SendFrom of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->SendFrom__parent_caller(ns3::Ptr< ns3::Packet  > (packet_ptr), source2, dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsBroadcast(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsBroadcast of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsBroadcast__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMtu(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    uint16_t retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMtu of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetMtu__parent_caller();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsBridge(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsBridge of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsBridge__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_DoStart(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetNode(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetNode of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetNode__parent_caller(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetAddress(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    PyNs3Address *py_Address;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetAddress of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::Address retval = helper->GetAddress__parent_caller();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsLinkUp(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsLinkUp of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsLinkUp__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetIfIndex(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetIfIndex of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetIfIndex__parent_caller(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetInstanceTypeId(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetAddress(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *address;
    ns3::Address address2;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetAddress of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetAddress__parent_caller(address2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetBroadcast(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    PyNs3Address *py_Address;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetBroadcast of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::Address retval = helper->GetBroadcast__parent_caller();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_AddLinkChangeCallback(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl1> callback_cb_impl;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl1> (callback);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddLinkChangeCallback of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddLinkChangeCallback__parent_caller(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetReceiveCallback(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl5> cb_cb_impl;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl5> (cb);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetReceiveCallback of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetReceiveCallback__parent_caller(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsMulticast(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsMulticast of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsMulticast__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetMtu(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    int mtu;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &mtu)) {
        return NULL;
    }
    if (mtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetMtu of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->SetMtu__parent_caller(mtu);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SupportsSendFrom(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SupportsSendFrom of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->SupportsSendFrom__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetChannel(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    PyNs3Channel *py_Channel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetChannel of class NonCommunicatingNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetChannel__parent_caller();
    if (!(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Channel__PythonHelper).name())
    {
        py_Channel = reinterpret_cast< PyNs3Channel* >(reinterpret_cast< PyNs3Channel__PythonHelper* >(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Channel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Channel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Channel = NULL;
        } else {
            py_Channel = (PyNs3Channel *) wrapper_lookup_iter->second;
            Py_INCREF(py_Channel);
        }
    
        if (py_Channel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))), &PyNs3Channel_Type);
            py_Channel = PyObject_GC_New(PyNs3Channel, wrapper_type);
            py_Channel->inst_dict = NULL;
            py_Channel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Channel *> (ns3::PeekPointer (retval))->Ref();
            py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Channel->obj] = (PyObject *) py_Channel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Channel);
    return py_retval;
}

PyObject *
PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_NotifyNewAggregate(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3NonCommunicatingNetDevice__PythonHelper *helper = dynamic_cast< PyNs3NonCommunicatingNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


ns3::Address
PyNs3NonCommunicatingNetDevice__PythonHelper::GetAddress() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetAddress();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetAddress", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetAddress();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetAddress();
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3NonCommunicatingNetDevice__PythonHelper::GetBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetBroadcast();
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Channel >
PyNs3NonCommunicatingNetDevice__PythonHelper::GetChannel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3Channel *tmp_Channel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetChannel();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetChannel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetChannel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Channel_Type, &tmp_Channel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetChannel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Channel  > (tmp_Channel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3NonCommunicatingNetDevice__PythonHelper::GetIfIndex() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetIfIndex"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetIfIndex();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetIfIndex", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetIfIndex();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetIfIndex();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3NonCommunicatingNetDevice__PythonHelper::GetMtu() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMtu();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMtu", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMtu();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMtu();
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMtu();
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3NonCommunicatingNetDevice__PythonHelper::GetMulticast(ns3::Ipv4Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMulticast(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(addr);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMulticast", (char *) "N", py_Ipv4Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMulticast(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMulticast(addr);
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3NonCommunicatingNetDevice__PythonHelper::GetMulticast(ns3::Ipv6Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMulticast(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(addr);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMulticast", (char *) "N", py_Ipv6Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMulticast(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetMulticast(addr);
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Node >
PyNs3NonCommunicatingNetDevice__PythonHelper::GetNode() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *tmp_Node;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetNode();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetNode", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetNode();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Node_Type, &tmp_Node)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::GetNode();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Node  > (tmp_Node->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::IsBridge() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsBridge"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsBridge();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsBridge", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsBridge();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsBridge();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::IsBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsBroadcast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::IsLinkUp() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsLinkUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsLinkUp();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsLinkUp", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsLinkUp();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsLinkUp();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::IsMulticast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsMulticast();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsMulticast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsMulticast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsMulticast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::IsPointToPoint() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsPointToPoint"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsPointToPoint();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsPointToPoint", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsPointToPoint();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::IsPointToPoint();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::NeedsArp() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NeedsArp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::NeedsArp();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NeedsArp", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::NeedsArp();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::NeedsArp();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::Send(ns3::Ptr< ns3::Packet > packet, ns3::Address const & dest, uint16_t protocolNumber)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::Send(packet, dest, protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(dest);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_Send", (char *) "NNi", py_Packet, py_Address, (int) protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::Send(packet, dest, protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::Send(packet, dest, protocolNumber);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::SendFrom(ns3::Ptr< ns3::Packet > packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    PyNs3Address *py_Address2;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SendFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(source);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_Address2 = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address2->obj = new ns3::Address(dest);
    PyNs3Address_wrapper_registry[(void *) py_Address2->obj] = (PyObject *) py_Address2;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SendFrom", (char *) "NNNi", py_Packet, py_Address, py_Address2, (int) protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::SetAddress(ns3::Address address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::NonCommunicatingNetDevice::SetAddress(address);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetAddress", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::SetIfIndex(uint32_t const index)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetIfIndex"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::NonCommunicatingNetDevice::SetIfIndex(index);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetIfIndex", (char *) "N", PyLong_FromUnsignedLong(index));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3NonCommunicatingNetDevice__PythonHelper::SetMtu(uint16_t const mtu)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SetMtu(mtu);
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetMtu", (char *) "i", (int) mtu);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SetMtu(mtu);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SetMtu(mtu);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::SetNode(ns3::Ptr< ns3::Node > node)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::NonCommunicatingNetDevice::SetNode(node);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    if (typeid(*(const_cast<ns3::Node *> (ns3::PeekPointer (node)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = (PyNs3Node*) (((PyNs3Node__PythonHelper*) const_cast<ns3::Node *> (ns3::PeekPointer (node)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (node));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (node)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Node *> (ns3::PeekPointer (node))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (node))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (node));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetNode", (char *) "N", py_Node);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}



bool
PyNs3NonCommunicatingNetDevice__PythonHelper::SupportsSendFrom() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SupportsSendFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SupportsSendFrom();
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = const_cast< ns3::NonCommunicatingNetDevice* >((const ns3::NonCommunicatingNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SupportsSendFrom", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SupportsSendFrom();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::NonCommunicatingNetDevice::SupportsSendFrom();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::NonCommunicatingNetDevice *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = (ns3::NonCommunicatingNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3NonCommunicatingNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3NonCommunicatingNetDevice__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3NonCommunicatingNetDevice__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3NonCommunicatingNetDevice__tp_init__0(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3NonCommunicatingNetDevice *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NonCommunicatingNetDevice_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3NonCommunicatingNetDevice_Type)
    {
        self->obj = new PyNs3NonCommunicatingNetDevice__PythonHelper(*((PyNs3NonCommunicatingNetDevice *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3NonCommunicatingNetDevice__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::NonCommunicatingNetDevice(*((PyNs3NonCommunicatingNetDevice *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3NonCommunicatingNetDevice__tp_init__1(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3NonCommunicatingNetDevice_Type)
    {
        self->obj = new PyNs3NonCommunicatingNetDevice__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3NonCommunicatingNetDevice__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::NonCommunicatingNetDevice();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3NonCommunicatingNetDevice__tp_init(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3NonCommunicatingNetDevice__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3NonCommunicatingNetDevice__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetMulticast__0(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = self->obj->GetMulticast(*((PyNs3Ipv4Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetMulticast__1(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *addr;
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = self->obj->GetMulticast(*((PyNs3Ipv6Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject * _wrap_PyNs3NonCommunicatingNetDevice_GetMulticast(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3NonCommunicatingNetDevice_GetMulticast__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3NonCommunicatingNetDevice_GetMulticast__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_IsPointToPoint(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsPointToPoint();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::NonCommunicatingNetDevice::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_Send(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    const char *keywords[] = {"packet", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!Oi", (char **) keywords, &PyNs3Packet_Type, &packet, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetIfIndex(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetIfIndex();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_NeedsArp(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->NeedsArp();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetPromiscReceiveCallback(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl4> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl4> (cb);
    self->obj->SetPromiscReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::Address const&, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetNode(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetNode();
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SendFrom(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *source;
    ns3::Address source2;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    const char *keywords[] = {"packet", "source", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!OOi", (char **) keywords, &PyNs3Packet_Type, &packet, &source, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->SendFrom(ns3::Ptr< ns3::Packet  > (packet_ptr), source2, dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_IsBroadcast(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsBroadcast();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetChannel(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Channel *c;
    ns3::Channel *c_ptr;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Channel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::Channel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetMtu(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetMtu();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_IsBridge(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsBridge();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetNode(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetAddress(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_IsLinkUp(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsLinkUp();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetIfIndex(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    self->obj->SetIfIndex(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetPhy(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Object *phy;
    ns3::Object *phy_ptr;
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Object_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    self->obj->SetPhy(ns3::Ptr< ns3::Object  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetAddress(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *address;
    ns3::Address address2;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        return NULL;
    }
    self->obj->SetAddress(address2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetBroadcast(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetBroadcast();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_AddLinkChangeCallback(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl1> callback_cb_impl;
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl1> (callback);
    self->obj->AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetReceiveCallback(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl5> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl5> (cb);
    self->obj->SetReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_IsMulticast(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsMulticast();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SetMtu(PyNs3NonCommunicatingNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    int mtu;
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &mtu)) {
        return NULL;
    }
    if (mtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->SetMtu(mtu);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetPhy(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Object > retval;
    PyNs3Object *py_Object;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPhy();
    if (!(const_cast<ns3::Object *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Object *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Object__PythonHelper).name())
    {
        py_Object = reinterpret_cast< PyNs3Object* >(reinterpret_cast< PyNs3Object__PythonHelper* >(const_cast<ns3::Object *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Object->obj = const_cast<ns3::Object *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Object);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Object *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Object = NULL;
        } else {
            py_Object = (PyNs3Object *) wrapper_lookup_iter->second;
            Py_INCREF(py_Object);
        }
    
        if (py_Object == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Object *> (ns3::PeekPointer (retval)))), &PyNs3Object_Type);
            py_Object = PyObject_GC_New(PyNs3Object, wrapper_type);
            py_Object->inst_dict = NULL;
            py_Object->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Object *> (ns3::PeekPointer (retval))->Ref();
            py_Object->obj = const_cast<ns3::Object *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Object->obj] = (PyObject *) py_Object;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Object);
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_SupportsSendFrom(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->SupportsSendFrom();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3NonCommunicatingNetDevice_GetChannel(PyNs3NonCommunicatingNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3Channel *py_Channel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetChannel();
    if (!(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Channel__PythonHelper).name())
    {
        py_Channel = reinterpret_cast< PyNs3Channel* >(reinterpret_cast< PyNs3Channel__PythonHelper* >(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Channel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Channel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Channel = NULL;
        } else {
            py_Channel = (PyNs3Channel *) wrapper_lookup_iter->second;
            Py_INCREF(py_Channel);
        }
    
        if (py_Channel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))), &PyNs3Channel_Type);
            py_Channel = PyObject_GC_New(PyNs3Channel, wrapper_type);
            py_Channel->inst_dict = NULL;
            py_Channel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Channel *> (ns3::PeekPointer (retval))->Ref();
            py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Channel->obj] = (PyObject *) py_Channel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Channel);
    return py_retval;
}


static PyObject*
_wrap_PyNs3NonCommunicatingNetDevice__copy__(PyNs3NonCommunicatingNetDevice *self)
{

    PyNs3NonCommunicatingNetDevice *py_copy;
    py_copy = PyObject_GC_New(PyNs3NonCommunicatingNetDevice, &PyNs3NonCommunicatingNetDevice_Type);
    py_copy->obj = new ns3::NonCommunicatingNetDevice(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3NonCommunicatingNetDevice_methods[] = {
    {(char *) "GetMulticast", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetMulticast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsPointToPoint", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_IsPointToPoint, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIfIndex", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetIfIndex, METH_NOARGS, NULL },
    {(char *) "NeedsArp", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_NeedsArp, METH_NOARGS, NULL },
    {(char *) "SetPromiscReceiveCallback", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetPromiscReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNode", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetNode, METH_NOARGS, NULL },
    {(char *) "SendFrom", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SendFrom, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsBroadcast", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_IsBroadcast, METH_NOARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetMtu, METH_NOARGS, NULL },
    {(char *) "IsBridge", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_IsBridge, METH_NOARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetAddress, METH_NOARGS, NULL },
    {(char *) "IsLinkUp", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_IsLinkUp, METH_NOARGS, NULL },
    {(char *) "SetIfIndex", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetIfIndex, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPhy", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetPhy, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetBroadcast", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetBroadcast, METH_NOARGS, NULL },
    {(char *) "AddLinkChangeCallback", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_AddLinkChangeCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReceiveCallback", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsMulticast", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_IsMulticast, METH_NOARGS, NULL },
    {(char *) "SetMtu", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPhy", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetPhy, METH_NOARGS, NULL },
    {(char *) "SupportsSendFrom", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_SupportsSendFrom, METH_NOARGS, NULL },
    {(char *) "GetChannel", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice_GetChannel, METH_NOARGS, NULL },
    {(char *) "_GetMulticast", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMulticast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_IsPointToPoint", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsPointToPoint, METH_NOARGS, NULL },
    {(char *) "_Send", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetIfIndex", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetIfIndex, METH_NOARGS, NULL },
    {(char *) "_NeedsArp", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_NeedsArp, METH_NOARGS, NULL },
    {(char *) "_SetPromiscReceiveCallback", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetPromiscReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetNode", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetNode, METH_NOARGS, NULL },
    {(char *) "_SendFrom", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SendFrom, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_IsBroadcast", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsBroadcast, METH_NOARGS, NULL },
    {(char *) "_GetMtu", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetMtu, METH_NOARGS, NULL },
    {(char *) "_IsBridge", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsBridge, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_SetNode", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetAddress", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetAddress, METH_NOARGS, NULL },
    {(char *) "_IsLinkUp", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsLinkUp, METH_NOARGS, NULL },
    {(char *) "_SetIfIndex", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetIfIndex, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_SetAddress", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_GetBroadcast", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetBroadcast, METH_NOARGS, NULL },
    {(char *) "_AddLinkChangeCallback", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_AddLinkChangeCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetReceiveCallback", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_IsMulticast", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_IsMulticast, METH_NOARGS, NULL },
    {(char *) "_SetMtu", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SupportsSendFrom", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_SupportsSendFrom, METH_NOARGS, NULL },
    {(char *) "_GetChannel", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_GetChannel, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3NonCommunicatingNetDevice__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3NonCommunicatingNetDevice__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3NonCommunicatingNetDevice__tp_clear(PyNs3NonCommunicatingNetDevice *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::NonCommunicatingNetDevice *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3NonCommunicatingNetDevice__tp_traverse(PyNs3NonCommunicatingNetDevice *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3NonCommunicatingNetDevice__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3NonCommunicatingNetDevice__tp_dealloc(PyNs3NonCommunicatingNetDevice *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3NonCommunicatingNetDevice__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3NonCommunicatingNetDevice__tp_richcompare (PyNs3NonCommunicatingNetDevice *PYBINDGEN_UNUSED(self), PyNs3NonCommunicatingNetDevice *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3NonCommunicatingNetDevice_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3NonCommunicatingNetDevice_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.NonCommunicatingNetDevice",            /* tp_name */
    sizeof(PyNs3NonCommunicatingNetDevice),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3NonCommunicatingNetDevice__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3NonCommunicatingNetDevice__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3NonCommunicatingNetDevice__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3NonCommunicatingNetDevice__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3NonCommunicatingNetDevice_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3NonCommunicatingNetDevice, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3NonCommunicatingNetDevice__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_DoStart(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_StartRx(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method StartRx of class ShannonSpectrumErrorModel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->StartRx__parent_caller(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_DoDispose(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class ShannonSpectrumErrorModel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_IsRxCorrect(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsRxCorrect of class ShannonSpectrumErrorModel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsRxCorrect__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_EvaluateChunk(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *sinr;
    PyNs3Time *duration;
    PyNs3ShannonSpectrumErrorModel__PythonHelper *helper = dynamic_cast< PyNs3ShannonSpectrumErrorModel__PythonHelper* >(self->obj);
    const char *keywords[] = {"sinr", "duration", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &sinr, &PyNs3Time_Type, &duration)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method EvaluateChunk of class ShannonSpectrumErrorModel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->EvaluateChunk__parent_caller(*((PyNs3SpectrumValue *) sinr)->obj, *((PyNs3Time *) duration)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3ShannonSpectrumErrorModel__PythonHelper::EvaluateChunk(ns3::SpectrumValue const & sinr, ns3::Time duration)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ShannonSpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumValue *py_SpectrumValue;
    PyNs3Time *py_Time;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_EvaluateChunk"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ShannonSpectrumErrorModel::EvaluateChunk(sinr, duration);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = (ns3::ShannonSpectrumErrorModel*) this;
    py_SpectrumValue = PyObject_New(PyNs3SpectrumValue, &PyNs3SpectrumValue_Type);
    py_SpectrumValue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumValue->obj = new ns3::SpectrumValue(sinr);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumValue->obj] = (PyObject *) py_SpectrumValue;
    py_Time = PyObject_New(PyNs3Time, &PyNs3Time_Type);
    py_Time->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Time->obj = new ns3::Time(duration);
    PyNs3Time_wrapper_registry[(void *) py_Time->obj] = (PyObject *) py_Time;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_EvaluateChunk", (char *) "NN", py_SpectrumValue, py_Time);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3ShannonSpectrumErrorModel__PythonHelper::IsRxCorrect()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ShannonSpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsRxCorrect"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::ShannonSpectrumErrorModel::IsRxCorrect();
    }
    self_obj_before = reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = (ns3::ShannonSpectrumErrorModel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsRxCorrect", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::ShannonSpectrumErrorModel::IsRxCorrect();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::ShannonSpectrumErrorModel::IsRxCorrect();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3ShannonSpectrumErrorModel__PythonHelper::StartRx(ns3::Ptr< ns3::Packet const > p)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ShannonSpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ShannonSpectrumErrorModel::StartRx(p);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = (ns3::ShannonSpectrumErrorModel*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (p)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (p))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (p))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (p));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "N", py_Packet);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ShannonSpectrumErrorModel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ShannonSpectrumErrorModel *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ShannonSpectrumErrorModel::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = (ns3::ShannonSpectrumErrorModel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ShannonSpectrumErrorModel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3ShannonSpectrumErrorModel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3ShannonSpectrumErrorModel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ShannonSpectrumErrorModel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3ShannonSpectrumErrorModel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3ShannonSpectrumErrorModel__tp_init__0(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3ShannonSpectrumErrorModel_Type)
    {
        self->obj = new PyNs3ShannonSpectrumErrorModel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3ShannonSpectrumErrorModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::ShannonSpectrumErrorModel();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3ShannonSpectrumErrorModel__tp_init__1(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3ShannonSpectrumErrorModel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3ShannonSpectrumErrorModel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3ShannonSpectrumErrorModel_Type)
    {
        self->obj = new PyNs3ShannonSpectrumErrorModel__PythonHelper(*((PyNs3ShannonSpectrumErrorModel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3ShannonSpectrumErrorModel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::ShannonSpectrumErrorModel(*((PyNs3ShannonSpectrumErrorModel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3ShannonSpectrumErrorModel__tp_init(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3ShannonSpectrumErrorModel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3ShannonSpectrumErrorModel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3ShannonSpectrumErrorModel_IsRxCorrect(PyNs3ShannonSpectrumErrorModel *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsRxCorrect();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3ShannonSpectrumErrorModel_EvaluateChunk(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumValue *sinr;
    PyNs3Time *duration;
    const char *keywords[] = {"sinr", "duration", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyNs3SpectrumValue_Type, &sinr, &PyNs3Time_Type, &duration)) {
        return NULL;
    }
    self->obj->EvaluateChunk(*((PyNs3SpectrumValue *) sinr)->obj, *((PyNs3Time *) duration)->obj);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3ShannonSpectrumErrorModel_StartRx(PyNs3ShannonSpectrumErrorModel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3ShannonSpectrumErrorModel__copy__(PyNs3ShannonSpectrumErrorModel *self)
{

    PyNs3ShannonSpectrumErrorModel *py_copy;
    py_copy = PyObject_GC_New(PyNs3ShannonSpectrumErrorModel, &PyNs3ShannonSpectrumErrorModel_Type);
    py_copy->obj = new ns3::ShannonSpectrumErrorModel(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3ShannonSpectrumErrorModel_methods[] = {
    {(char *) "IsRxCorrect", (PyCFunction) _wrap_PyNs3ShannonSpectrumErrorModel_IsRxCorrect, METH_NOARGS, NULL },
    {(char *) "EvaluateChunk", (PyCFunction) _wrap_PyNs3ShannonSpectrumErrorModel_EvaluateChunk, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3ShannonSpectrumErrorModel_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_StartRx", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_IsRxCorrect", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_IsRxCorrect, METH_NOARGS, NULL },
    {(char *) "_EvaluateChunk", (PyCFunction) PyNs3ShannonSpectrumErrorModel__PythonHelper::_wrap_EvaluateChunk, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3ShannonSpectrumErrorModel__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3ShannonSpectrumErrorModel__tp_clear(PyNs3ShannonSpectrumErrorModel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::ShannonSpectrumErrorModel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3ShannonSpectrumErrorModel__tp_traverse(PyNs3ShannonSpectrumErrorModel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3ShannonSpectrumErrorModel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3ShannonSpectrumErrorModel__tp_dealloc(PyNs3ShannonSpectrumErrorModel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3ShannonSpectrumErrorModel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3ShannonSpectrumErrorModel__tp_richcompare (PyNs3ShannonSpectrumErrorModel *PYBINDGEN_UNUSED(self), PyNs3ShannonSpectrumErrorModel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3ShannonSpectrumErrorModel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3ShannonSpectrumErrorModel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.ShannonSpectrumErrorModel",            /* tp_name */
    sizeof(PyNs3ShannonSpectrumErrorModel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3ShannonSpectrumErrorModel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3ShannonSpectrumErrorModel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3ShannonSpectrumErrorModel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3ShannonSpectrumErrorModel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3ShannonSpectrumErrorModel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3ShannonSpectrumErrorModel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3ShannonSpectrumErrorModel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetRxSpectrumModel(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetRxSpectrumModel of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetRxSpectrumModel__parent_caller();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_SetMobility(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetMobility of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetMobility__parent_caller(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_DoDispose(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_Stop(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method Stop of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->Stop__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_DoStart(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_Start(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method Start of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->Start__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_SetChannel(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetChannel of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetChannel__parent_caller(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_StartRx(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method StartRx of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->StartRx__parent_caller(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_SetDevice(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetDevice of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetDevice__parent_caller(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetMobility(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMobility of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetMobility__parent_caller();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetDevice(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetDevice of class SpectrumAnalyzer is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetDevice__parent_caller();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

PyObject *
PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    PyNs3SpectrumAnalyzer__PythonHelper *helper = dynamic_cast< PyNs3SpectrumAnalyzer__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3SpectrumAnalyzer__PythonHelper::GetDevice()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetDevice();
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetDevice();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetDevice();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::MobilityModel >
PyNs3SpectrumAnalyzer__PythonHelper::GetMobility()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *tmp_MobilityModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetMobility();
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMobility", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetMobility();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3MobilityModel_Type, &tmp_MobilityModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetMobility();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::MobilityModel  > (tmp_MobilityModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumModel const >
PyNs3SpectrumAnalyzer__PythonHelper::GetRxSpectrumModel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *tmp_SpectrumModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetRxSpectrumModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetRxSpectrumModel();
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = const_cast< ns3::SpectrumAnalyzer* >((const ns3::SpectrumAnalyzer*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetRxSpectrumModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetRxSpectrumModel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumModel_Type, &tmp_SpectrumModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SpectrumAnalyzer::GetRxSpectrumModel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumModel  > (tmp_SpectrumModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::SetChannel(ns3::Ptr< ns3::SpectrumChannel > c)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumChannel *py_SpectrumChannel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::SetChannel(c);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    if (typeid(*(const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))).name() == typeid(PyNs3SpectrumChannel__PythonHelper).name())
    {
        py_SpectrumChannel = (PyNs3SpectrumChannel*) (((PyNs3SpectrumChannel__PythonHelper*) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)))->m_pyself);
        py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
        Py_INCREF(py_SpectrumChannel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumChannel = NULL;
        } else {
            py_SpectrumChannel = (PyNs3SpectrumChannel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumChannel);
        }
    
        if (py_SpectrumChannel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))), &PyNs3SpectrumChannel_Type);
            py_SpectrumChannel = PyObject_GC_New(PyNs3SpectrumChannel, wrapper_type);
            py_SpectrumChannel->inst_dict = NULL;
            py_SpectrumChannel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c))->Ref();
            py_SpectrumChannel->obj = const_cast<ns3::SpectrumChannel *> (ns3::PeekPointer (c));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumChannel->obj] = (PyObject *) py_SpectrumChannel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetChannel", (char *) "N", py_SpectrumChannel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::SetDevice(ns3::Ptr< ns3::NetDevice > d)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::SetDevice(d);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    if (typeid(*(const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = (PyNs3NetDevice*) (((PyNs3NetDevice__PythonHelper*) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (d)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (d))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (d));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetDevice", (char *) "N", py_NetDevice);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::SetMobility(ns3::Ptr< ns3::MobilityModel > m)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetMobility"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::SetMobility(m);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    if (typeid(*(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = (PyNs3MobilityModel*) (((PyNs3MobilityModel__PythonHelper*) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (m));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetMobility", (char *) "N", py_MobilityModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::Start()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_Start"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::Start();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_Start", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::StartRx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::StartRx(params);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::Stop()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_Stop"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::Stop();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_Stop", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SpectrumAnalyzer::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::GenerateReport()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumAnalyzer *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GenerateReport"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = (ns3::SpectrumAnalyzer*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GenerateReport", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumAnalyzer* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3SpectrumAnalyzer__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumAnalyzer__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SpectrumAnalyzer__tp_init__0(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumAnalyzer *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumAnalyzer_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumAnalyzer_Type)
    {
        self->obj = new PyNs3SpectrumAnalyzer__PythonHelper(*((PyNs3SpectrumAnalyzer *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumAnalyzer__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::SpectrumAnalyzer(*((PyNs3SpectrumAnalyzer *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3SpectrumAnalyzer__tp_init__1(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumAnalyzer_Type)
    {
        self->obj = new PyNs3SpectrumAnalyzer__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumAnalyzer__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::SpectrumAnalyzer();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3SpectrumAnalyzer__tp_init(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumAnalyzer__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumAnalyzer__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_GetRxSpectrumModel(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumModel const > retval;
    PyNs3SpectrumModel *py_SpectrumModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetRxSpectrumModel();
    if (!(const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumModel = NULL;
    } else {
        py_SpectrumModel = (PyNs3SpectrumModel *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumModel);
    }
    
    if (py_SpectrumModel == NULL) {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumModel_Type);
        py_SpectrumModel = PyObject_New(PyNs3SpectrumModel, wrapper_type);
        py_SpectrumModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval))->Ref();
        py_SpectrumModel->obj = const_cast<ns3::SpectrumModel *> (ns3::PeekPointer (retval));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumModel->obj] = (PyObject *) py_SpectrumModel;
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_SetMobility(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3MobilityModel *m;
    ns3::MobilityModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MobilityModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->SetMobility(ns3::Ptr< ns3::MobilityModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::SpectrumAnalyzer::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_Stop(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    
    self->obj->Stop();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_Start(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    
    self->obj->Start();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_SetChannel(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel *c;
    ns3::SpectrumChannel *c_ptr;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::SpectrumChannel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_StartRx(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartRx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_SetDevice(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3NetDevice *d;
    ns3::NetDevice *d_ptr;
    const char *keywords[] = {"d", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3NetDevice_Type, &d)) {
        return NULL;
    }
    d_ptr = (d ? d->obj : NULL);
    self->obj->SetDevice(ns3::Ptr< ns3::NetDevice  > (d_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_GetMobility(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::MobilityModel > retval;
    PyNs3MobilityModel *py_MobilityModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetMobility();
    if (!(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3MobilityModel__PythonHelper).name())
    {
        py_MobilityModel = reinterpret_cast< PyNs3MobilityModel* >(reinterpret_cast< PyNs3MobilityModel__PythonHelper* >(const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_MobilityModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_MobilityModel = NULL;
        } else {
            py_MobilityModel = (PyNs3MobilityModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_MobilityModel);
        }
    
        if (py_MobilityModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval)))), &PyNs3MobilityModel_Type);
            py_MobilityModel = PyObject_GC_New(PyNs3MobilityModel, wrapper_type);
            py_MobilityModel->inst_dict = NULL;
            py_MobilityModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval))->Ref();
            py_MobilityModel->obj = const_cast<ns3::MobilityModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_MobilityModel->obj] = (PyObject *) py_MobilityModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_MobilityModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_GetDevice(PyNs3SpectrumAnalyzer *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetDevice();
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumAnalyzer_SetRxSpectrumModel(PyNs3SpectrumAnalyzer *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumModel *m;
    ns3::SpectrumModel *m_ptr;
    const char *keywords[] = {"m", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumModel_Type, &m)) {
        return NULL;
    }
    m_ptr = (m ? m->obj : NULL);
    self->obj->SetRxSpectrumModel(ns3::Ptr< ns3::SpectrumModel  > (m_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SpectrumAnalyzer__copy__(PyNs3SpectrumAnalyzer *self)
{

    PyNs3SpectrumAnalyzer *py_copy;
    py_copy = PyObject_GC_New(PyNs3SpectrumAnalyzer, &PyNs3SpectrumAnalyzer_Type);
    py_copy->obj = new ns3::SpectrumAnalyzer(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SpectrumAnalyzer_methods[] = {
    {(char *) "GetRxSpectrumModel", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "SetMobility", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Stop", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_Stop, METH_NOARGS, NULL },
    {(char *) "Start", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_Start, METH_NOARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "StartRx", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetDevice", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMobility", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_GetMobility, METH_NOARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_GetDevice, METH_NOARGS, NULL },
    {(char *) "SetRxSpectrumModel", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer_SetRxSpectrumModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetRxSpectrumModel", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetRxSpectrumModel, METH_NOARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_SetMobility", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_SetMobility, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_Stop", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_Stop, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_Start", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_Start, METH_NOARGS, NULL },
    {(char *) "_SetChannel", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_StartRx", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_StartRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetDevice", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_SetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetMobility", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetMobility, METH_NOARGS, NULL },
    {(char *) "_GetDevice", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetDevice, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SpectrumAnalyzer__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SpectrumAnalyzer__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SpectrumAnalyzer__tp_clear(PyNs3SpectrumAnalyzer *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SpectrumAnalyzer *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SpectrumAnalyzer__tp_traverse(PyNs3SpectrumAnalyzer *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SpectrumAnalyzer__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SpectrumAnalyzer__tp_dealloc(PyNs3SpectrumAnalyzer *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SpectrumAnalyzer__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumAnalyzer__tp_richcompare (PyNs3SpectrumAnalyzer *PYBINDGEN_UNUSED(self), PyNs3SpectrumAnalyzer *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumAnalyzer_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumAnalyzer_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumAnalyzer",            /* tp_name */
    sizeof(PyNs3SpectrumAnalyzer),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumAnalyzer__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SpectrumAnalyzer__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SpectrumAnalyzer__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumAnalyzer__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumAnalyzer_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SpectrumAnalyzer, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumAnalyzer__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SpectrumChannel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumChannel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumChannel__PythonHelper::_wrap_DoDispose(PyNs3SpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumChannel__PythonHelper::_wrap_DoStart(PyNs3SpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SpectrumChannel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SpectrumChannel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

void
PyNs3SpectrumChannel__PythonHelper::AddPropagationLossModel(ns3::Ptr< ns3::PropagationLossModel > loss)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3PropagationLossModel *py_PropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = (ns3::SpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)))).name() == typeid(PyNs3PropagationLossModel__PythonHelper).name())
    {
        py_PropagationLossModel = (PyNs3PropagationLossModel*) (((PyNs3PropagationLossModel__PythonHelper*) const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)))->m_pyself);
        py_PropagationLossModel->obj = const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss));
        Py_INCREF(py_PropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_PropagationLossModel = NULL;
        } else {
            py_PropagationLossModel = (PyNs3PropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_PropagationLossModel);
        }
    
        if (py_PropagationLossModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss))), &PyNs3PropagationLossModel_Type);
            py_PropagationLossModel = PyObject_GC_New(PyNs3PropagationLossModel, wrapper_type);
            py_PropagationLossModel->inst_dict = NULL;
            py_PropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss))->Ref();
            py_PropagationLossModel->obj = const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss));
            PyNs3ObjectBase_wrapper_registry[(void *) py_PropagationLossModel->obj] = (PyObject *) py_PropagationLossModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddPropagationLossModel", (char *) "N", py_PropagationLossModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::AddRx(ns3::Ptr< ns3::SpectrumPhy > phy)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = (ns3::SpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = (PyNs3SpectrumPhy*) (((PyNs3SpectrumPhy__PythonHelper*) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddRx", (char *) "N", py_SpectrumPhy);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::AddSpectrumPropagationLossModel(ns3::Ptr< ns3::SpectrumPropagationLossModel > loss)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddSpectrumPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = (ns3::SpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel*) (((PyNs3SpectrumPropagationLossModel__PythonHelper*) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddSpectrumPropagationLossModel", (char *) "N", py_SpectrumPropagationLossModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::SetPropagationDelayModel(ns3::Ptr< ns3::PropagationDelayModel > delay)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3PropagationDelayModel *py_PropagationDelayModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetPropagationDelayModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = (ns3::SpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)))).name() == typeid(PyNs3PropagationDelayModel__PythonHelper).name())
    {
        py_PropagationDelayModel = (PyNs3PropagationDelayModel*) (((PyNs3PropagationDelayModel__PythonHelper*) const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)))->m_pyself);
        py_PropagationDelayModel->obj = const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay));
        Py_INCREF(py_PropagationDelayModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_PropagationDelayModel = NULL;
        } else {
            py_PropagationDelayModel = (PyNs3PropagationDelayModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_PropagationDelayModel);
        }
    
        if (py_PropagationDelayModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay))), &PyNs3PropagationDelayModel_Type);
            py_PropagationDelayModel = PyObject_GC_New(PyNs3PropagationDelayModel, wrapper_type);
            py_PropagationDelayModel->inst_dict = NULL;
            py_PropagationDelayModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay))->Ref();
            py_PropagationDelayModel->obj = const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay));
            PyNs3ObjectBase_wrapper_registry[(void *) py_PropagationDelayModel->obj] = (PyObject *) py_PropagationDelayModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetPropagationDelayModel", (char *) "N", py_PropagationDelayModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::StartTx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartTx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = (ns3::SpectrumChannel*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartTx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

uint32_t
PyNs3SpectrumChannel__PythonHelper::GetNDevices() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Channel *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetNDevices"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Channel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = const_cast< ns3::Channel* >((const ns3::Channel*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetNDevices", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::NetDevice >
PyNs3SpectrumChannel__PythonHelper::GetDevice(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Channel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    self_obj_before = reinterpret_cast< PyNs3Channel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = const_cast< ns3::Channel* >((const ns3::Channel*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
    
        PyErr_Print();
        Py_FatalError("Error detected, but parent virtual is pure virtual or private virtual, "
                      "and return is a class without trival constructor");
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Channel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::TypeId
PyNs3SpectrumChannel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SpectrumChannel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SpectrumChannel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SpectrumChannel__tp_init__0(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumChannel_Type)
    {
        self->obj = new PyNs3SpectrumChannel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumChannel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumChannel' cannot be constructed");
        return -1;
    }
    return 0;
}

static int
_wrap_PyNs3SpectrumChannel__tp_init__1(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SpectrumChannel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumChannel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SpectrumChannel_Type)
    {
        self->obj = new PyNs3SpectrumChannel__PythonHelper(*((PyNs3SpectrumChannel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SpectrumChannel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        PyErr_SetString(PyExc_TypeError, "class 'SpectrumChannel' cannot be constructed");
        return -1;
    }
    return 0;
}

int _wrap_PyNs3SpectrumChannel__tp_init(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SpectrumChannel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SpectrumChannel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SpectrumChannel_StartTx(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartTx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannel_AddPropagationLossModel(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationLossModel *loss;
    ns3::PropagationLossModel *loss_ptr;
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    self->obj->AddPropagationLossModel(ns3::Ptr< ns3::PropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannel_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::SpectrumChannel::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannel_AddSpectrumPropagationLossModel(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *loss;
    ns3::SpectrumPropagationLossModel *loss_ptr;
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    self->obj->AddSpectrumPropagationLossModel(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannel_SetPropagationDelayModel(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationDelayModel *delay;
    ns3::PropagationDelayModel *delay_ptr;
    const char *keywords[] = {"delay", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationDelayModel_Type, &delay)) {
        return NULL;
    }
    delay_ptr = (delay ? delay->obj : NULL);
    self->obj->SetPropagationDelayModel(ns3::Ptr< ns3::PropagationDelayModel  > (delay_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SpectrumChannel_AddRx(PyNs3SpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *phy;
    ns3::SpectrumPhy *phy_ptr;
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhy_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    self->obj->AddRx(ns3::Ptr< ns3::SpectrumPhy  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

static PyMethodDef PyNs3SpectrumChannel_methods[] = {
    {(char *) "StartTx", (PyCFunction) _wrap_PyNs3SpectrumChannel_StartTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddPropagationLossModel", (PyCFunction) _wrap_PyNs3SpectrumChannel_AddPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3SpectrumChannel_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "AddSpectrumPropagationLossModel", (PyCFunction) _wrap_PyNs3SpectrumChannel_AddSpectrumPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPropagationDelayModel", (PyCFunction) _wrap_PyNs3SpectrumChannel_SetPropagationDelayModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddRx", (PyCFunction) _wrap_PyNs3SpectrumChannel_AddRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SpectrumChannel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SpectrumChannel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3SpectrumChannel__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SpectrumChannel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SpectrumChannel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SpectrumChannel__tp_clear(PyNs3SpectrumChannel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SpectrumChannel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SpectrumChannel__tp_traverse(PyNs3SpectrumChannel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SpectrumChannel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SpectrumChannel__tp_dealloc(PyNs3SpectrumChannel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SpectrumChannel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SpectrumChannel__tp_richcompare (PyNs3SpectrumChannel *PYBINDGEN_UNUSED(self), PyNs3SpectrumChannel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SpectrumChannel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SpectrumChannel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SpectrumChannel",            /* tp_name */
    sizeof(PyNs3SpectrumChannel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SpectrumChannel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SpectrumChannel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SpectrumChannel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SpectrumChannel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SpectrumChannel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SpectrumChannel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SpectrumChannel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMulticast__0(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMulticast of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = helper->GetMulticast__parent_caller(*((PyNs3Ipv4Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMulticast__1(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *addr;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMulticast of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = helper->GetMulticast__parent_caller(*((PyNs3Ipv6Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject * PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMulticast(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMulticast__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMulticast__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsPointToPoint(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsPointToPoint of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsPointToPoint__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_Send(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"packet", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!Oi", (char **) keywords, &PyNs3Packet_Type, &packet, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method Send of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->Send__parent_caller(ns3::Ptr< ns3::Packet  > (packet_ptr), dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetIfIndex(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetIfIndex of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetIfIndex__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_NeedsArp(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NeedsArp of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->NeedsArp__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetPromiscReceiveCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl4> cb_cb_impl;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl4> (cb);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetPromiscReceiveCallback of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetPromiscReceiveCallback__parent_caller(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::Address const&, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetNode(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetNode of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetNode__parent_caller();
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SendFrom(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *source;
    ns3::Address source2;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"packet", "source", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!OOi", (char **) keywords, &PyNs3Packet_Type, &packet, &source, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SendFrom of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->SendFrom__parent_caller(ns3::Ptr< ns3::Packet  > (packet_ptr), source2, dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsBroadcast(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsBroadcast of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsBroadcast__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMtu(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    uint16_t retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetMtu of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetMtu__parent_caller();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsBridge(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsBridge of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsBridge__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_DoStart(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetNode(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetNode of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetNode__parent_caller(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetAddress(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    PyNs3Address *py_Address;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetAddress of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::Address retval = helper->GetAddress__parent_caller();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsLinkUp(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsLinkUp of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsLinkUp__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetIfIndex(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetIfIndex of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetIfIndex__parent_caller(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetInstanceTypeId(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetAddress(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *address;
    ns3::Address address2;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetAddress of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetAddress__parent_caller(address2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_NotifyNewAggregate(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetBroadcast(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    PyNs3Address *py_Address;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetBroadcast of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::Address retval = helper->GetBroadcast__parent_caller();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_AddLinkChangeCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl1> callback_cb_impl;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl1> (callback);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddLinkChangeCallback of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddLinkChangeCallback__parent_caller(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetReceiveCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl5> cb_cb_impl;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl5> (cb);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetReceiveCallback of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetReceiveCallback__parent_caller(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsMulticast(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method IsMulticast of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->IsMulticast__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetMtu(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    int mtu;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &mtu)) {
        return NULL;
    }
    if (mtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetMtu of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->SetMtu__parent_caller(mtu);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SupportsSendFrom(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SupportsSendFrom of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->SupportsSendFrom__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetChannel(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    PyNs3Channel *py_Channel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetChannel of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetChannel__parent_caller();
    if (!(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Channel__PythonHelper).name())
    {
        py_Channel = reinterpret_cast< PyNs3Channel* >(reinterpret_cast< PyNs3Channel__PythonHelper* >(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Channel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Channel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Channel = NULL;
        } else {
            py_Channel = (PyNs3Channel *) wrapper_lookup_iter->second;
            Py_INCREF(py_Channel);
        }
    
        if (py_Channel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))), &PyNs3Channel_Type);
            py_Channel = PyObject_GC_New(PyNs3Channel, wrapper_type);
            py_Channel->inst_dict = NULL;
            py_Channel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Channel *> (ns3::PeekPointer (retval))->Ref();
            py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Channel->obj] = (PyObject *) py_Channel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Channel);
    return py_retval;
}

PyObject *
PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetQueue(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Queue *queue;
    ns3::Queue *queue_ptr;
    PyNs3AlohaNoackNetDevice__PythonHelper *helper = dynamic_cast< PyNs3AlohaNoackNetDevice__PythonHelper* >(self->obj);
    const char *keywords[] = {"queue", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Queue_Type, &queue)) {
        return NULL;
    }
    queue_ptr = (queue ? queue->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetQueue of class AlohaNoackNetDevice is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetQueue__parent_caller(ns3::Ptr< ns3::Queue  > (queue_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


ns3::Address
PyNs3AlohaNoackNetDevice__PythonHelper::GetAddress() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetAddress();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetAddress", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetAddress();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetAddress();
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3AlohaNoackNetDevice__PythonHelper::GetBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetBroadcast();
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Channel >
PyNs3AlohaNoackNetDevice__PythonHelper::GetChannel() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3Channel *tmp_Channel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetChannel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetChannel();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetChannel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetChannel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Channel_Type, &tmp_Channel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetChannel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Channel  > (tmp_Channel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3AlohaNoackNetDevice__PythonHelper::GetIfIndex() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetIfIndex"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetIfIndex();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetIfIndex", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetIfIndex();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetIfIndex();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint16_t
PyNs3AlohaNoackNetDevice__PythonHelper::GetMtu() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    uint16_t retval;
    int tmp;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMtu();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMtu", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMtu();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &tmp)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMtu();
    }
    if (tmp > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMtu();
    }
    retval = tmp;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3AlohaNoackNetDevice__PythonHelper::GetMulticast(ns3::Ipv4Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv4Address *py_Ipv4Address;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMulticast(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_Ipv4Address = PyObject_New(PyNs3Ipv4Address, &PyNs3Ipv4Address_Type);
    py_Ipv4Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv4Address->obj = new ns3::Ipv4Address(addr);
    PyNs3Ipv4Address_wrapper_registry[(void *) py_Ipv4Address->obj] = (PyObject *) py_Ipv4Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMulticast", (char *) "N", py_Ipv4Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMulticast(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMulticast(addr);
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Address
PyNs3AlohaNoackNetDevice__PythonHelper::GetMulticast(ns3::Ipv6Address addr) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Ipv6Address *py_Ipv6Address;
    PyNs3Address *tmp_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMulticast(addr);
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_Ipv6Address = PyObject_New(PyNs3Ipv6Address, &PyNs3Ipv6Address_Type);
    py_Ipv6Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Ipv6Address->obj = new ns3::Ipv6Address(addr);
    PyNs3Ipv6Address_wrapper_registry[(void *) py_Ipv6Address->obj] = (PyObject *) py_Ipv6Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetMulticast", (char *) "N", py_Ipv6Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMulticast(addr);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Address_Type, &tmp_Address)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetMulticast(addr);
    }
    ns3::Address retval = *tmp_Address->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::Node >
PyNs3AlohaNoackNetDevice__PythonHelper::GetNode() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *tmp_Node;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetNode();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetNode", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetNode();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3Node_Type, &tmp_Node)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::GetNode();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::Node  > (tmp_Node->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::IsBridge() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsBridge"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsBridge();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsBridge", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsBridge();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsBridge();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::IsBroadcast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsBroadcast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsBroadcast();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsBroadcast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsBroadcast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsBroadcast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::IsLinkUp() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsLinkUp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsLinkUp();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsLinkUp", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsLinkUp();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsLinkUp();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::IsMulticast() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsMulticast"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsMulticast();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsMulticast", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsMulticast();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsMulticast();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::IsPointToPoint() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_IsPointToPoint"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsPointToPoint();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_IsPointToPoint", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsPointToPoint();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::IsPointToPoint();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::NeedsArp() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NeedsArp"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::NeedsArp();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NeedsArp", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::NeedsArp();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::NeedsArp();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::Send(ns3::Ptr< ns3::Packet > packet, ns3::Address const & dest, uint16_t protocolNumber)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_Send"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::Send(packet, dest, protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(dest);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_Send", (char *) "NNi", py_Packet, py_Address, (int) protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::Send(packet, dest, protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::Send(packet, dest, protocolNumber);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::SendFrom(ns3::Ptr< ns3::Packet > packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *py_Packet;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3Address *py_Address;
    PyNs3Address *py_Address2;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SendFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::Packet *> (ns3::PeekPointer (packet)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_Packet = NULL;
    } else {
        py_Packet = (PyNs3Packet *) wrapper_lookup_iter->second;
        Py_INCREF(py_Packet);
    }
    
    if (py_Packet == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Packet *> (ns3::PeekPointer (packet))), &PyNs3Packet_Type);
        py_Packet = PyObject_New(PyNs3Packet, wrapper_type);
        py_Packet->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::Packet *> (ns3::PeekPointer (packet))->Ref();
        py_Packet->obj = const_cast<ns3::Packet *> (ns3::PeekPointer (packet));
        PyNs3Empty_wrapper_registry[(void *) py_Packet->obj] = (PyObject *) py_Packet;
    }
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(source);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_Address2 = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address2->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address2->obj = new ns3::Address(dest);
    PyNs3Address_wrapper_registry[(void *) py_Address2->obj] = (PyObject *) py_Address2;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SendFrom", (char *) "NNNi", py_Packet, py_Address, py_Address2, (int) protocolNumber);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SendFrom(packet, source, dest, protocolNumber);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::SetAddress(ns3::Address address)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetAddress"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::AlohaNoackNetDevice::SetAddress(address);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(address);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetAddress", (char *) "N", py_Address);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::SetIfIndex(uint32_t const index)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetIfIndex"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::AlohaNoackNetDevice::SetIfIndex(index);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetIfIndex", (char *) "N", PyLong_FromUnsignedLong(index));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

bool
PyNs3AlohaNoackNetDevice__PythonHelper::SetMtu(uint16_t const mtu)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetMtu"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SetMtu(mtu);
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetMtu", (char *) "i", (int) mtu);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SetMtu(mtu);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SetMtu(mtu);
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::SetNode(ns3::Ptr< ns3::Node > node)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetNode"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::AlohaNoackNetDevice::SetNode(node);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    if (typeid(*(const_cast<ns3::Node *> (ns3::PeekPointer (node)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = (PyNs3Node*) (((PyNs3Node__PythonHelper*) const_cast<ns3::Node *> (ns3::PeekPointer (node)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (node));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (node)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Node *> (ns3::PeekPointer (node))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (node))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (node));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetNode", (char *) "N", py_Node);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


void
PyNs3AlohaNoackNetDevice__PythonHelper::SetQueue(ns3::Ptr< ns3::Queue > queue)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    PyNs3Queue *py_Queue;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetQueue"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::AlohaNoackNetDevice::SetQueue(queue);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    if (typeid(*(const_cast<ns3::Queue *> (ns3::PeekPointer (queue)))).name() == typeid(PyNs3Queue__PythonHelper).name())
    {
        py_Queue = (PyNs3Queue*) (((PyNs3Queue__PythonHelper*) const_cast<ns3::Queue *> (ns3::PeekPointer (queue)))->m_pyself);
        py_Queue->obj = const_cast<ns3::Queue *> (ns3::PeekPointer (queue));
        Py_INCREF(py_Queue);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Queue *> (ns3::PeekPointer (queue)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Queue = NULL;
        } else {
            py_Queue = (PyNs3Queue *) wrapper_lookup_iter->second;
            Py_INCREF(py_Queue);
        }
    
        if (py_Queue == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::Queue *> (ns3::PeekPointer (queue))), &PyNs3Queue_Type);
            py_Queue = PyObject_GC_New(PyNs3Queue, wrapper_type);
            py_Queue->inst_dict = NULL;
            py_Queue->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Queue *> (ns3::PeekPointer (queue))->Ref();
            py_Queue->obj = const_cast<ns3::Queue *> (ns3::PeekPointer (queue));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Queue->obj] = (PyObject *) py_Queue;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetQueue", (char *) "N", py_Queue);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


bool
PyNs3AlohaNoackNetDevice__PythonHelper::SupportsSendFrom() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    bool retval;
    PyObject *py_boolretval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SupportsSendFrom"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SupportsSendFrom();
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = const_cast< ns3::AlohaNoackNetDevice* >((const ns3::AlohaNoackNetDevice*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SupportsSendFrom", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SupportsSendFrom();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O", &py_boolretval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::AlohaNoackNetDevice::SupportsSendFrom();
    }
    retval = PyObject_IsTrue(py_boolretval);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::AlohaNoackNetDevice *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj;
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = (ns3::AlohaNoackNetDevice*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3AlohaNoackNetDevice* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3AlohaNoackNetDevice__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3AlohaNoackNetDevice__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3AlohaNoackNetDevice__tp_init__0(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3AlohaNoackNetDevice *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3AlohaNoackNetDevice_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3AlohaNoackNetDevice_Type)
    {
        self->obj = new PyNs3AlohaNoackNetDevice__PythonHelper(*((PyNs3AlohaNoackNetDevice *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3AlohaNoackNetDevice__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::AlohaNoackNetDevice(*((PyNs3AlohaNoackNetDevice *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3AlohaNoackNetDevice__tp_init__1(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3AlohaNoackNetDevice_Type)
    {
        self->obj = new PyNs3AlohaNoackNetDevice__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3AlohaNoackNetDevice__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::AlohaNoackNetDevice();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3AlohaNoackNetDevice__tp_init(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AlohaNoackNetDevice__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AlohaNoackNetDevice__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}



PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetMulticast__0(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv4Address *addr;
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv4Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = self->obj->GetMulticast(*((PyNs3Ipv4Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetMulticast__1(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    PyNs3Ipv6Address *addr;
    const char *keywords[] = {"addr", NULL};
    PyNs3Address *py_Address;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Ipv6Address_Type, &addr)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    ns3::Address retval = self->obj->GetMulticast(*((PyNs3Ipv6Address *) addr)->obj);
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}

PyObject * _wrap_PyNs3AlohaNoackNetDevice_GetMulticast(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3AlohaNoackNetDevice_GetMulticast__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3AlohaNoackNetDevice_GetMulticast__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_IsPointToPoint(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsPointToPoint();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::AlohaNoackNetDevice::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_Send(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    const char *keywords[] = {"packet", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!Oi", (char **) keywords, &PyNs3Packet_Type, &packet, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->Send(ns3::Ptr< ns3::Packet  > (packet_ptr), dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetIfIndex(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetIfIndex();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_NeedsArp(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->NeedsArp();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_NotifyReceptionEndOk(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *p;
    ns3::Packet *p_ptr;
    const char *keywords[] = {"p", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &p)) {
        return NULL;
    }
    p_ptr = (p ? p->obj : NULL);
    self->obj->NotifyReceptionEndOk(ns3::Ptr< ns3::Packet  > (p_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetPromiscReceiveCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl4> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl4> (cb);
    self->obj->SetPromiscReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::Address const&, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetNode(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Node > retval;
    PyNs3Node *py_Node;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetNode();
    if (!(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Node__PythonHelper).name())
    {
        py_Node = reinterpret_cast< PyNs3Node* >(reinterpret_cast< PyNs3Node__PythonHelper* >(const_cast<ns3::Node *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Node);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Node *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Node = NULL;
        } else {
            py_Node = (PyNs3Node *) wrapper_lookup_iter->second;
            Py_INCREF(py_Node);
        }
    
        if (py_Node == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Node *> (ns3::PeekPointer (retval)))), &PyNs3Node_Type);
            py_Node = PyObject_GC_New(PyNs3Node, wrapper_type);
            py_Node->inst_dict = NULL;
            py_Node->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Node *> (ns3::PeekPointer (retval))->Ref();
            py_Node->obj = const_cast<ns3::Node *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Node->obj] = (PyObject *) py_Node;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Node);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SendFrom(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    PyNs3Packet *packet;
    ns3::Packet *packet_ptr;
    PyObject *source;
    ns3::Address source2;
    PyObject *dest;
    ns3::Address dest2;
    int protocolNumber;
    const char *keywords[] = {"packet", "source", "dest", "protocolNumber", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!OOi", (char **) keywords, &PyNs3Packet_Type, &packet, &source, &dest, &protocolNumber)) {
        return NULL;
    }
    packet_ptr = (packet ? packet->obj : NULL);
    if (PyObject_IsInstance(source, (PyObject*) &PyNs3Address_Type)) {
        source2 = *((PyNs3Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv4Address_Type)) {
        source2 = *((PyNs3Ipv4Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Ipv6Address_Type)) {
        source2 = *((PyNs3Ipv6Address *) source)->obj;
    } else if (PyObject_IsInstance(source, (PyObject*) &PyNs3Mac48Address_Type)) {
        source2 = *((PyNs3Mac48Address *) source)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", source->ob_type->tp_name);
        return NULL;
    }
    if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Address_Type)) {
        dest2 = *((PyNs3Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv4Address_Type)) {
        dest2 = *((PyNs3Ipv4Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Ipv6Address_Type)) {
        dest2 = *((PyNs3Ipv6Address *) dest)->obj;
    } else if (PyObject_IsInstance(dest, (PyObject*) &PyNs3Mac48Address_Type)) {
        dest2 = *((PyNs3Mac48Address *) dest)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", dest->ob_type->tp_name);
        return NULL;
    }
    if (protocolNumber > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->SendFrom(ns3::Ptr< ns3::Packet  > (packet_ptr), source2, dest2, protocolNumber);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_NotifyReceptionStart(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    
    self->obj->NotifyReceptionStart();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_NotifyReceptionEndError(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    
    self->obj->NotifyReceptionEndError();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetChannel(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Channel *c;
    ns3::Channel *c_ptr;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Channel_Type, &c)) {
        return NULL;
    }
    c_ptr = (c ? c->obj : NULL);
    self->obj->SetChannel(ns3::Ptr< ns3::Channel  > (c_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetMtu(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    uint16_t retval;
    
    retval = self->obj->GetMtu();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_NotifyTransmissionEnd(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Packet *arg0;
    ns3::Packet *arg0_ptr;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Packet_Type, &arg0)) {
        return NULL;
    }
    arg0_ptr = (arg0 ? arg0->obj : NULL);
    self->obj->NotifyTransmissionEnd(ns3::Ptr< ns3::Packet  > (arg0_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetGenericPhyTxStartCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *c;
    ns3::Ptr<PythonCallbackImpl3> c_cb_impl;
    const char *keywords[] = {"c", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &c)) {
        return NULL;
    }
    if (!PyCallable_Check(c)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'c' must be callbale");
        return NULL;
    }
    c_cb_impl = ns3::Create<PythonCallbackImpl3> (c);
    self->obj->SetGenericPhyTxStartCallback(ns3::Callback<bool, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (c_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetNode(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Node *node;
    ns3::Node *node_ptr;
    const char *keywords[] = {"node", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Node_Type, &node)) {
        return NULL;
    }
    node_ptr = (node ? node->obj : NULL);
    self->obj->SetNode(ns3::Ptr< ns3::Node  > (node_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_IsBridge(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsBridge();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetAddress(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetAddress();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_IsLinkUp(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsLinkUp();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetIfIndex(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int index;
    const char *keywords[] = {"index", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &index)) {
        return NULL;
    }
    self->obj->SetIfIndex(index);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetPhy(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Object *phy;
    ns3::Object *phy_ptr;
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Object_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    self->obj->SetPhy(ns3::Ptr< ns3::Object  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetAddress(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *address;
    ns3::Address address2;
    const char *keywords[] = {"address", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &address)) {
        return NULL;
    }
    if (PyObject_IsInstance(address, (PyObject*) &PyNs3Address_Type)) {
        address2 = *((PyNs3Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv4Address_Type)) {
        address2 = *((PyNs3Ipv4Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Ipv6Address_Type)) {
        address2 = *((PyNs3Ipv6Address *) address)->obj;
    } else if (PyObject_IsInstance(address, (PyObject*) &PyNs3Mac48Address_Type)) {
        address2 = *((PyNs3Mac48Address *) address)->obj;
    } else {
    
        PyErr_Format(PyExc_TypeError, "parameter must an instance of one of the types (Address, Ipv4Address, Ipv6Address, Mac48Address), not %s", address->ob_type->tp_name);
        return NULL;
    }
    self->obj->SetAddress(address2);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetBroadcast(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    PyNs3Address *py_Address;
    
    ns3::Address retval = self->obj->GetBroadcast();
    py_Address = PyObject_New(PyNs3Address, &PyNs3Address_Type);
    py_Address->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Address->obj = new ns3::Address(retval);
    PyNs3Address_wrapper_registry[(void *) py_Address->obj] = (PyObject *) py_Address;
    py_retval = Py_BuildValue((char *) "N", py_Address);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_AddLinkChangeCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *callback;
    ns3::Ptr<PythonCallbackImpl1> callback_cb_impl;
    const char *keywords[] = {"callback", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &callback)) {
        return NULL;
    }
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'callback' must be callbale");
        return NULL;
    }
    callback_cb_impl = ns3::Create<PythonCallbackImpl1> (callback);
    self->obj->AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (callback_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetReceiveCallback(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyObject *cb;
    ns3::Ptr<PythonCallbackImpl5> cb_cb_impl;
    const char *keywords[] = {"cb", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &cb)) {
        return NULL;
    }
    if (!PyCallable_Check(cb)) {
        PyErr_SetString(PyExc_TypeError, "parameter 'cb' must be callbale");
        return NULL;
    }
    cb_cb_impl = ns3::Create<PythonCallbackImpl5> (cb);
    self->obj->SetReceiveCallback(ns3::Callback<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<ns3::Packet const>, unsigned short, ns3::Address const&, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> (cb_cb_impl));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_IsMulticast(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsMulticast();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetMtu(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    bool retval;
    int mtu;
    const char *keywords[] = {"mtu", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &mtu)) {
        return NULL;
    }
    if (mtu > 0xffff) {
        PyErr_SetString(PyExc_ValueError, "Out of range");
        return NULL;
    }
    retval = self->obj->SetMtu(mtu);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetPhy(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Object > retval;
    PyNs3Object *py_Object;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetPhy();
    if (!(const_cast<ns3::Object *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Object *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Object__PythonHelper).name())
    {
        py_Object = reinterpret_cast< PyNs3Object* >(reinterpret_cast< PyNs3Object__PythonHelper* >(const_cast<ns3::Object *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Object->obj = const_cast<ns3::Object *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Object);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Object *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Object = NULL;
        } else {
            py_Object = (PyNs3Object *) wrapper_lookup_iter->second;
            Py_INCREF(py_Object);
        }
    
        if (py_Object == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Object *> (ns3::PeekPointer (retval)))), &PyNs3Object_Type);
            py_Object = PyObject_GC_New(PyNs3Object, wrapper_type);
            py_Object->inst_dict = NULL;
            py_Object->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Object *> (ns3::PeekPointer (retval))->Ref();
            py_Object->obj = const_cast<ns3::Object *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Object->obj] = (PyObject *) py_Object;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Object);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SupportsSendFrom(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->SupportsSendFrom();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_GetChannel(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::Channel > retval;
    PyNs3Channel *py_Channel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetChannel();
    if (!(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3Channel__PythonHelper).name())
    {
        py_Channel = reinterpret_cast< PyNs3Channel* >(reinterpret_cast< PyNs3Channel__PythonHelper* >(const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_Channel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::Channel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_Channel = NULL;
        } else {
            py_Channel = (PyNs3Channel *) wrapper_lookup_iter->second;
            Py_INCREF(py_Channel);
        }
    
        if (py_Channel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::Channel *> (ns3::PeekPointer (retval)))), &PyNs3Channel_Type);
            py_Channel = PyObject_GC_New(PyNs3Channel, wrapper_type);
            py_Channel->inst_dict = NULL;
            py_Channel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::Channel *> (ns3::PeekPointer (retval))->Ref();
            py_Channel->obj = const_cast<ns3::Channel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_Channel->obj] = (PyObject *) py_Channel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_Channel);
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_SetQueue(PyNs3AlohaNoackNetDevice *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3Queue *queue;
    ns3::Queue *queue_ptr;
    const char *keywords[] = {"queue", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3Queue_Type, &queue)) {
        return NULL;
    }
    queue_ptr = (queue ? queue->obj : NULL);
    self->obj->SetQueue(ns3::Ptr< ns3::Queue  > (queue_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3AlohaNoackNetDevice_IsBroadcast(PyNs3AlohaNoackNetDevice *self)
{
    PyObject *py_retval;
    bool retval;
    
    retval = self->obj->IsBroadcast();
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}


static PyObject*
_wrap_PyNs3AlohaNoackNetDevice__copy__(PyNs3AlohaNoackNetDevice *self)
{

    PyNs3AlohaNoackNetDevice *py_copy;
    py_copy = PyObject_GC_New(PyNs3AlohaNoackNetDevice, &PyNs3AlohaNoackNetDevice_Type);
    py_copy->obj = new ns3::AlohaNoackNetDevice(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3AlohaNoackNetDevice_methods[] = {
    {(char *) "GetMulticast", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetMulticast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsPointToPoint", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_IsPointToPoint, METH_NOARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Send", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetIfIndex", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetIfIndex, METH_NOARGS, NULL },
    {(char *) "NeedsArp", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_NeedsArp, METH_NOARGS, NULL },
    {(char *) "NotifyReceptionEndOk", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_NotifyReceptionEndOk, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPromiscReceiveCallback", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetPromiscReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetNode", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetNode, METH_NOARGS, NULL },
    {(char *) "SendFrom", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SendFrom, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NotifyReceptionStart", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_NotifyReceptionStart, METH_NOARGS, NULL },
    {(char *) "NotifyReceptionEndError", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_NotifyReceptionEndError, METH_NOARGS, NULL },
    {(char *) "SetChannel", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetChannel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetMtu", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetMtu, METH_NOARGS, NULL },
    {(char *) "NotifyTransmissionEnd", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_NotifyTransmissionEnd, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetGenericPhyTxStartCallback", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetGenericPhyTxStartCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetNode", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsBridge", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_IsBridge, METH_NOARGS, NULL },
    {(char *) "GetAddress", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetAddress, METH_NOARGS, NULL },
    {(char *) "IsLinkUp", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_IsLinkUp, METH_NOARGS, NULL },
    {(char *) "SetIfIndex", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetIfIndex, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPhy", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetPhy, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetAddress", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetBroadcast", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetBroadcast, METH_NOARGS, NULL },
    {(char *) "AddLinkChangeCallback", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_AddLinkChangeCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetReceiveCallback", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsMulticast", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_IsMulticast, METH_NOARGS, NULL },
    {(char *) "SetMtu", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetPhy", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetPhy, METH_NOARGS, NULL },
    {(char *) "SupportsSendFrom", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SupportsSendFrom, METH_NOARGS, NULL },
    {(char *) "GetChannel", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_GetChannel, METH_NOARGS, NULL },
    {(char *) "SetQueue", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_SetQueue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "IsBroadcast", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice_IsBroadcast, METH_NOARGS, NULL },
    {(char *) "_GetMulticast", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMulticast, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_IsPointToPoint", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsPointToPoint, METH_NOARGS, NULL },
    {(char *) "_Send", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_Send, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetIfIndex", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetIfIndex, METH_NOARGS, NULL },
    {(char *) "_NeedsArp", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_NeedsArp, METH_NOARGS, NULL },
    {(char *) "_SetPromiscReceiveCallback", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetPromiscReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetNode", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetNode, METH_NOARGS, NULL },
    {(char *) "_SendFrom", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SendFrom, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_IsBroadcast", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsBroadcast, METH_NOARGS, NULL },
    {(char *) "_GetMtu", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetMtu, METH_NOARGS, NULL },
    {(char *) "_IsBridge", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsBridge, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_SetNode", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetNode, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetAddress", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetAddress, METH_NOARGS, NULL },
    {(char *) "_IsLinkUp", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsLinkUp, METH_NOARGS, NULL },
    {(char *) "_SetIfIndex", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetIfIndex, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_SetAddress", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetAddress, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetBroadcast", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetBroadcast, METH_NOARGS, NULL },
    {(char *) "_AddLinkChangeCallback", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_AddLinkChangeCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetReceiveCallback", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetReceiveCallback, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_IsMulticast", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_IsMulticast, METH_NOARGS, NULL },
    {(char *) "_SetMtu", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetMtu, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SupportsSendFrom", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SupportsSendFrom, METH_NOARGS, NULL },
    {(char *) "_GetChannel", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_GetChannel, METH_NOARGS, NULL },
    {(char *) "_SetQueue", (PyCFunction) PyNs3AlohaNoackNetDevice__PythonHelper::_wrap_SetQueue, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3AlohaNoackNetDevice__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3AlohaNoackNetDevice__tp_clear(PyNs3AlohaNoackNetDevice *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::AlohaNoackNetDevice *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3AlohaNoackNetDevice__tp_traverse(PyNs3AlohaNoackNetDevice *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3AlohaNoackNetDevice__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3AlohaNoackNetDevice__tp_dealloc(PyNs3AlohaNoackNetDevice *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3AlohaNoackNetDevice__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3AlohaNoackNetDevice__tp_richcompare (PyNs3AlohaNoackNetDevice *PYBINDGEN_UNUSED(self), PyNs3AlohaNoackNetDevice *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3AlohaNoackNetDevice_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3AlohaNoackNetDevice_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.AlohaNoackNetDevice",            /* tp_name */
    sizeof(PyNs3AlohaNoackNetDevice),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3AlohaNoackNetDevice__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3AlohaNoackNetDevice__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3AlohaNoackNetDevice__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3AlohaNoackNetDevice__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3AlohaNoackNetDevice_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3AlohaNoackNetDevice, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3AlohaNoackNetDevice__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_StartTx(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method StartTx of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->StartTx__parent_caller(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_AddPropagationLossModel(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationLossModel *loss;
    ns3::PropagationLossModel *loss_ptr;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddPropagationLossModel of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddPropagationLossModel__parent_caller(ns3::Ptr< ns3::PropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_DoStart(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetNDevices(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetNDevices of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetNDevices__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetSpectrumPropagationLossModel(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPropagationLossModel > retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetSpectrumPropagationLossModel of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetSpectrumPropagationLossModel__parent_caller();
    if (!(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(reinterpret_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPropagationLossModel);
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_DoDispose(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoDispose of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoDispose__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_AddSpectrumPropagationLossModel(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *loss;
    ns3::SpectrumPropagationLossModel *loss_ptr;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddSpectrumPropagationLossModel of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddSpectrumPropagationLossModel__parent_caller(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_SetPropagationDelayModel(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationDelayModel *delay;
    ns3::PropagationDelayModel *delay_ptr;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"delay", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationDelayModel_Type, &delay)) {
        return NULL;
    }
    delay_ptr = (delay ? delay->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetPropagationDelayModel of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetPropagationDelayModel__parent_caller(ns3::Ptr< ns3::PropagationDelayModel  > (delay_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetDevice(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int i;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"i", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetDevice of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetDevice__parent_caller(i);
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

PyObject *
PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_AddRx(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *phy;
    ns3::SpectrumPhy *phy_ptr;
    PyNs3MultiModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3MultiModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhy_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddRx of class MultiModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddRx__parent_caller(ns3::Ptr< ns3::SpectrumPhy  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::AddPropagationLossModel(ns3::Ptr< ns3::PropagationLossModel > loss)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3PropagationLossModel *py_PropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::MultiModelSpectrumChannel::AddPropagationLossModel(loss);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)))).name() == typeid(PyNs3PropagationLossModel__PythonHelper).name())
    {
        py_PropagationLossModel = (PyNs3PropagationLossModel*) (((PyNs3PropagationLossModel__PythonHelper*) const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)))->m_pyself);
        py_PropagationLossModel->obj = const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss));
        Py_INCREF(py_PropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_PropagationLossModel = NULL;
        } else {
            py_PropagationLossModel = (PyNs3PropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_PropagationLossModel);
        }
    
        if (py_PropagationLossModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss))), &PyNs3PropagationLossModel_Type);
            py_PropagationLossModel = PyObject_GC_New(PyNs3PropagationLossModel, wrapper_type);
            py_PropagationLossModel->inst_dict = NULL;
            py_PropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss))->Ref();
            py_PropagationLossModel->obj = const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss));
            PyNs3ObjectBase_wrapper_registry[(void *) py_PropagationLossModel->obj] = (PyObject *) py_PropagationLossModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddPropagationLossModel", (char *) "N", py_PropagationLossModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::AddRx(ns3::Ptr< ns3::SpectrumPhy > phy)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::MultiModelSpectrumChannel::AddRx(phy);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = (PyNs3SpectrumPhy*) (((PyNs3SpectrumPhy__PythonHelper*) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddRx", (char *) "N", py_SpectrumPhy);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::AddSpectrumPropagationLossModel(ns3::Ptr< ns3::SpectrumPropagationLossModel > loss)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddSpectrumPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::MultiModelSpectrumChannel::AddSpectrumPropagationLossModel(loss);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel*) (((PyNs3SpectrumPropagationLossModel__PythonHelper*) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddSpectrumPropagationLossModel", (char *) "N", py_SpectrumPropagationLossModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::NetDevice >
PyNs3MultiModelSpectrumChannel__PythonHelper::GetDevice(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetDevice(i);
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = const_cast< ns3::MultiModelSpectrumChannel* >((const ns3::MultiModelSpectrumChannel*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetDevice(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetDevice(i);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3MultiModelSpectrumChannel__PythonHelper::GetNDevices() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetNDevices"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetNDevices();
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = const_cast< ns3::MultiModelSpectrumChannel* >((const ns3::MultiModelSpectrumChannel*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetNDevices", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetNDevices();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetNDevices();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumPropagationLossModel >
PyNs3MultiModelSpectrumChannel__PythonHelper::GetSpectrumPropagationLossModel()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPropagationLossModel > retval;
    PyNs3SpectrumPropagationLossModel *tmp_SpectrumPropagationLossModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetSpectrumPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetSpectrumPropagationLossModel();
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetSpectrumPropagationLossModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetSpectrumPropagationLossModel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumPropagationLossModel_Type, &tmp_SpectrumPropagationLossModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::MultiModelSpectrumChannel::GetSpectrumPropagationLossModel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumPropagationLossModel  > (tmp_SpectrumPropagationLossModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::SetPropagationDelayModel(ns3::Ptr< ns3::PropagationDelayModel > delay)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3PropagationDelayModel *py_PropagationDelayModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetPropagationDelayModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::MultiModelSpectrumChannel::SetPropagationDelayModel(delay);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)))).name() == typeid(PyNs3PropagationDelayModel__PythonHelper).name())
    {
        py_PropagationDelayModel = (PyNs3PropagationDelayModel*) (((PyNs3PropagationDelayModel__PythonHelper*) const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)))->m_pyself);
        py_PropagationDelayModel->obj = const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay));
        Py_INCREF(py_PropagationDelayModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_PropagationDelayModel = NULL;
        } else {
            py_PropagationDelayModel = (PyNs3PropagationDelayModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_PropagationDelayModel);
        }
    
        if (py_PropagationDelayModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay))), &PyNs3PropagationDelayModel_Type);
            py_PropagationDelayModel = PyObject_GC_New(PyNs3PropagationDelayModel, wrapper_type);
            py_PropagationDelayModel->inst_dict = NULL;
            py_PropagationDelayModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay))->Ref();
            py_PropagationDelayModel->obj = const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay));
            PyNs3ObjectBase_wrapper_registry[(void *) py_PropagationDelayModel->obj] = (PyObject *) py_PropagationDelayModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetPropagationDelayModel", (char *) "N", py_PropagationDelayModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::StartTx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartTx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::MultiModelSpectrumChannel::StartTx(params);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartTx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::MultiModelSpectrumChannel::DoDispose();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::StartRx(ns3::Ptr< ns3::SpectrumSignalParameters > params, ns3::Ptr< ns3::SpectrumPhy > receiver)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::MultiModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter2;
    PyTypeObject *wrapper_type2 = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = (ns3::MultiModelSpectrumChannel*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    if (typeid(*(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver)))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = (PyNs3SpectrumPhy*) (((PyNs3SpectrumPhy__PythonHelper*) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver)))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter2 = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver)));
        if (wrapper_lookup_iter2 == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter2->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL)
        {
            wrapper_type2 = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type2);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (receiver));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartRx", (char *) "NN", py_SpectrumSignalParameters, py_SpectrumPhy);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3MultiModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3MultiModelSpectrumChannel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3MultiModelSpectrumChannel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3MultiModelSpectrumChannel__tp_init__0(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3MultiModelSpectrumChannel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3MultiModelSpectrumChannel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3MultiModelSpectrumChannel_Type)
    {
        self->obj = new PyNs3MultiModelSpectrumChannel__PythonHelper(*((PyNs3MultiModelSpectrumChannel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3MultiModelSpectrumChannel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::MultiModelSpectrumChannel(*((PyNs3MultiModelSpectrumChannel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3MultiModelSpectrumChannel__tp_init__1(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3MultiModelSpectrumChannel_Type)
    {
        self->obj = new PyNs3MultiModelSpectrumChannel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3MultiModelSpectrumChannel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::MultiModelSpectrumChannel();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3MultiModelSpectrumChannel__tp_init(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3MultiModelSpectrumChannel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3MultiModelSpectrumChannel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_StartTx(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartTx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_AddPropagationLossModel(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationLossModel *loss;
    ns3::PropagationLossModel *loss_ptr;
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    self->obj->AddPropagationLossModel(ns3::Ptr< ns3::PropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::MultiModelSpectrumChannel::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_GetNDevices(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNDevices();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_GetSpectrumPropagationLossModel(PyNs3MultiModelSpectrumChannel *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPropagationLossModel > retval;
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetSpectrumPropagationLossModel();
    if (!(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(reinterpret_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPropagationLossModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_AddSpectrumPropagationLossModel(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *loss;
    ns3::SpectrumPropagationLossModel *loss_ptr;
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    self->obj->AddSpectrumPropagationLossModel(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_SetPropagationDelayModel(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationDelayModel *delay;
    ns3::PropagationDelayModel *delay_ptr;
    const char *keywords[] = {"delay", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationDelayModel_Type, &delay)) {
        return NULL;
    }
    delay_ptr = (delay ? delay->obj : NULL);
    self->obj->SetPropagationDelayModel(ns3::Ptr< ns3::PropagationDelayModel  > (delay_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_GetDevice(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetDevice(i);
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3MultiModelSpectrumChannel_AddRx(PyNs3MultiModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *phy;
    ns3::SpectrumPhy *phy_ptr;
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhy_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    self->obj->AddRx(ns3::Ptr< ns3::SpectrumPhy  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3MultiModelSpectrumChannel__copy__(PyNs3MultiModelSpectrumChannel *self)
{

    PyNs3MultiModelSpectrumChannel *py_copy;
    py_copy = PyObject_GC_New(PyNs3MultiModelSpectrumChannel, &PyNs3MultiModelSpectrumChannel_Type);
    py_copy->obj = new ns3::MultiModelSpectrumChannel(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3MultiModelSpectrumChannel_methods[] = {
    {(char *) "StartTx", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_StartTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddPropagationLossModel", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_AddPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetNDevices", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_GetNDevices, METH_NOARGS, NULL },
    {(char *) "GetSpectrumPropagationLossModel", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_GetSpectrumPropagationLossModel, METH_NOARGS, NULL },
    {(char *) "AddSpectrumPropagationLossModel", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_AddSpectrumPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPropagationDelayModel", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_SetPropagationDelayModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_GetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddRx", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel_AddRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_StartTx", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_StartTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_AddPropagationLossModel", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_AddPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_GetNDevices", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetNDevices, METH_NOARGS, NULL },
    {(char *) "_GetSpectrumPropagationLossModel", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetSpectrumPropagationLossModel, METH_NOARGS, NULL },
    {(char *) "_DoDispose", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_DoDispose, METH_NOARGS, NULL },
    {(char *) "_AddSpectrumPropagationLossModel", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_AddSpectrumPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetPropagationDelayModel", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_SetPropagationDelayModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetDevice", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_GetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_AddRx", (PyCFunction) PyNs3MultiModelSpectrumChannel__PythonHelper::_wrap_AddRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3MultiModelSpectrumChannel__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3MultiModelSpectrumChannel__tp_clear(PyNs3MultiModelSpectrumChannel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::MultiModelSpectrumChannel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3MultiModelSpectrumChannel__tp_traverse(PyNs3MultiModelSpectrumChannel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3MultiModelSpectrumChannel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3MultiModelSpectrumChannel__tp_dealloc(PyNs3MultiModelSpectrumChannel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3MultiModelSpectrumChannel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3MultiModelSpectrumChannel__tp_richcompare (PyNs3MultiModelSpectrumChannel *PYBINDGEN_UNUSED(self), PyNs3MultiModelSpectrumChannel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3MultiModelSpectrumChannel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3MultiModelSpectrumChannel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.MultiModelSpectrumChannel",            /* tp_name */
    sizeof(PyNs3MultiModelSpectrumChannel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3MultiModelSpectrumChannel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3MultiModelSpectrumChannel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3MultiModelSpectrumChannel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3MultiModelSpectrumChannel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3MultiModelSpectrumChannel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3MultiModelSpectrumChannel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3MultiModelSpectrumChannel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_NotifyConstructionCompleted(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyConstructionCompleted of class ObjectBase is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyConstructionCompleted__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_StartTx(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method StartTx of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->StartTx__parent_caller(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_AddPropagationLossModel(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationLossModel *loss;
    ns3::PropagationLossModel *loss_ptr;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddPropagationLossModel of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddPropagationLossModel__parent_caller(ns3::Ptr< ns3::PropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_NotifyNewAggregate(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method NotifyNewAggregate of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->NotifyNewAggregate__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_DoStart(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method DoStart of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    helper->DoStart__parent_caller();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetNDevices(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    uint32_t retval;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetNDevices of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetNDevices__parent_caller();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetSpectrumPropagationLossModel(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPropagationLossModel > retval;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetSpectrumPropagationLossModel of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetSpectrumPropagationLossModel__parent_caller();
    if (!(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(reinterpret_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPropagationLossModel);
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetInstanceTypeId(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    PyNs3TypeId *py_TypeId;
    
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetInstanceTypeId of class Object is protected and can only be called by a subclass");
        return NULL;
    }
    ns3::TypeId retval = helper->GetInstanceTypeId__parent_caller();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_AddSpectrumPropagationLossModel(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *loss;
    ns3::SpectrumPropagationLossModel *loss_ptr;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddSpectrumPropagationLossModel of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddSpectrumPropagationLossModel__parent_caller(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_SetPropagationDelayModel(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationDelayModel *delay;
    ns3::PropagationDelayModel *delay_ptr;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"delay", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationDelayModel_Type, &delay)) {
        return NULL;
    }
    delay_ptr = (delay ? delay->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method SetPropagationDelayModel of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->SetPropagationDelayModel__parent_caller(ns3::Ptr< ns3::PropagationDelayModel  > (delay_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetDevice(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int i;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"i", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method GetDevice of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    retval = helper->GetDevice__parent_caller(i);
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}

PyObject *
PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_AddRx(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *phy;
    ns3::SpectrumPhy *phy_ptr;
    PyNs3SingleModelSpectrumChannel__PythonHelper *helper = dynamic_cast< PyNs3SingleModelSpectrumChannel__PythonHelper* >(self->obj);
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhy_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    if (helper == NULL) {
        PyErr_SetString(PyExc_TypeError, "Method AddRx of class SingleModelSpectrumChannel is protected and can only be called by a subclass");
        return NULL;
    }
    helper->AddRx__parent_caller(ns3::Ptr< ns3::SpectrumPhy  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::AddPropagationLossModel(ns3::Ptr< ns3::PropagationLossModel > loss)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3PropagationLossModel *py_PropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SingleModelSpectrumChannel::AddPropagationLossModel(loss);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)))).name() == typeid(PyNs3PropagationLossModel__PythonHelper).name())
    {
        py_PropagationLossModel = (PyNs3PropagationLossModel*) (((PyNs3PropagationLossModel__PythonHelper*) const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)))->m_pyself);
        py_PropagationLossModel->obj = const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss));
        Py_INCREF(py_PropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_PropagationLossModel = NULL;
        } else {
            py_PropagationLossModel = (PyNs3PropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_PropagationLossModel);
        }
    
        if (py_PropagationLossModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss))), &PyNs3PropagationLossModel_Type);
            py_PropagationLossModel = PyObject_GC_New(PyNs3PropagationLossModel, wrapper_type);
            py_PropagationLossModel->inst_dict = NULL;
            py_PropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss))->Ref();
            py_PropagationLossModel->obj = const_cast<ns3::PropagationLossModel *> (ns3::PeekPointer (loss));
            PyNs3ObjectBase_wrapper_registry[(void *) py_PropagationLossModel->obj] = (PyObject *) py_PropagationLossModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddPropagationLossModel", (char *) "N", py_PropagationLossModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::AddRx(ns3::Ptr< ns3::SpectrumPhy > phy)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddRx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SingleModelSpectrumChannel::AddRx(phy);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = (PyNs3SpectrumPhy*) (((PyNs3SpectrumPhy__PythonHelper*) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer (phy));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddRx", (char *) "N", py_SpectrumPhy);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::AddSpectrumPropagationLossModel(ns3::Ptr< ns3::SpectrumPropagationLossModel > loss)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_AddSpectrumPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SingleModelSpectrumChannel::AddSpectrumPropagationLossModel(loss);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel*) (((PyNs3SpectrumPropagationLossModel__PythonHelper*) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (loss));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_AddSpectrumPropagationLossModel", (char *) "N", py_SpectrumPropagationLossModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::Ptr< ns3::NetDevice >
PyNs3SingleModelSpectrumChannel__PythonHelper::GetDevice(uint32_t i) const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    PyNs3NetDevice *tmp_NetDevice;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetDevice"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetDevice(i);
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = const_cast< ns3::SingleModelSpectrumChannel* >((const ns3::SingleModelSpectrumChannel*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetDevice", (char *) "N", PyLong_FromUnsignedLong(i));
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetDevice(i);
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3NetDevice_Type, &tmp_NetDevice)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetDevice(i);
    }
    // dangerous!
    retval = ns3::Ptr< ns3::NetDevice  > (tmp_NetDevice->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

uint32_t
PyNs3SingleModelSpectrumChannel__PythonHelper::GetNDevices() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    uint32_t retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetNDevices"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetNDevices();
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = const_cast< ns3::SingleModelSpectrumChannel* >((const ns3::SingleModelSpectrumChannel*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetNDevices", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetNDevices();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &retval)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetNDevices();
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

ns3::Ptr< ns3::SpectrumPropagationLossModel >
PyNs3SingleModelSpectrumChannel__PythonHelper::GetSpectrumPropagationLossModel()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPropagationLossModel > retval;
    PyNs3SpectrumPropagationLossModel *tmp_SpectrumPropagationLossModel;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetSpectrumPropagationLossModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetSpectrumPropagationLossModel();
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetSpectrumPropagationLossModel", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetSpectrumPropagationLossModel();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumPropagationLossModel_Type, &tmp_SpectrumPropagationLossModel)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::SingleModelSpectrumChannel::GetSpectrumPropagationLossModel();
    }
    // dangerous!
    retval = ns3::Ptr< ns3::SpectrumPropagationLossModel  > (tmp_SpectrumPropagationLossModel->obj);
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::SetPropagationDelayModel(ns3::Ptr< ns3::PropagationDelayModel > delay)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3PropagationDelayModel *py_PropagationDelayModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_SetPropagationDelayModel"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SingleModelSpectrumChannel::SetPropagationDelayModel(delay);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    if (typeid(*(const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)))).name() == typeid(PyNs3PropagationDelayModel__PythonHelper).name())
    {
        py_PropagationDelayModel = (PyNs3PropagationDelayModel*) (((PyNs3PropagationDelayModel__PythonHelper*) const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)))->m_pyself);
        py_PropagationDelayModel->obj = const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay));
        Py_INCREF(py_PropagationDelayModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_PropagationDelayModel = NULL;
        } else {
            py_PropagationDelayModel = (PyNs3PropagationDelayModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_PropagationDelayModel);
        }
    
        if (py_PropagationDelayModel == NULL)
        {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid(*const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay))), &PyNs3PropagationDelayModel_Type);
            py_PropagationDelayModel = PyObject_GC_New(PyNs3PropagationDelayModel, wrapper_type);
            py_PropagationDelayModel->inst_dict = NULL;
            py_PropagationDelayModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay))->Ref();
            py_PropagationDelayModel->obj = const_cast<ns3::PropagationDelayModel *> (ns3::PeekPointer (delay));
            PyNs3ObjectBase_wrapper_registry[(void *) py_PropagationDelayModel->obj] = (PyObject *) py_PropagationDelayModel;
        }
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_SetPropagationDelayModel", (char *) "N", py_PropagationDelayModel);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::StartTx(ns3::Ptr< ns3::SpectrumSignalParameters > params)
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *py_SpectrumSignalParameters;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_StartTx"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::SingleModelSpectrumChannel::StartTx(params);
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    wrapper_lookup_iter = PyNs3Empty_wrapper_registry.find((void *) const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params)));
    if (wrapper_lookup_iter == PyNs3Empty_wrapper_registry.end()) {
        py_SpectrumSignalParameters = NULL;
    } else {
        py_SpectrumSignalParameters = (PyNs3SpectrumSignalParameters *) wrapper_lookup_iter->second;
        Py_INCREF(py_SpectrumSignalParameters);
    }
    
    if (py_SpectrumSignalParameters == NULL)
    {
        wrapper_type = PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.lookup_wrapper(typeid(*const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))), &PyNs3SpectrumSignalParameters_Type);
        py_SpectrumSignalParameters = PyObject_New(PyNs3SpectrumSignalParameters, wrapper_type);
        py_SpectrumSignalParameters->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params))->Ref();
        py_SpectrumSignalParameters->obj = const_cast<ns3::SpectrumSignalParameters *> (ns3::PeekPointer (params));
        PyNs3Empty_wrapper_registry[(void *) py_SpectrumSignalParameters->obj] = (PyObject *) py_SpectrumSignalParameters;
    }
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_StartTx", (char *) "N", py_SpectrumSignalParameters);
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::DoDispose()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::SingleModelSpectrumChannel *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoDispose"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj;
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = (ns3::SingleModelSpectrumChannel*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoDispose", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3SingleModelSpectrumChannel* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

ns3::TypeId
PyNs3SingleModelSpectrumChannel__PythonHelper::GetInstanceTypeId() const
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    PyNs3TypeId *tmp_TypeId;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_GetInstanceTypeId"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = const_cast< ns3::Object* >((const ns3::Object*) this);
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_GetInstanceTypeId", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    py_retval = Py_BuildValue((char*) "(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3TypeId_Type, &tmp_TypeId)) {
        PyErr_Print();
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return ns3::Object::GetInstanceTypeId();
    }
    ns3::TypeId retval = *tmp_TypeId->obj;
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return retval;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::DoStart()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_DoStart"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::DoStart();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_DoStart", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::NotifyNewAggregate()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::Object *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyNewAggregate"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::Object::NotifyNewAggregate();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3Object* >(m_pyself)->obj;
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = (ns3::Object*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyNewAggregate", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3Object* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}

void
PyNs3SingleModelSpectrumChannel__PythonHelper::NotifyConstructionCompleted()
{
    PyGILState_STATE __py_gil_state;
    PyObject *py_method;
    ns3::ObjectBase *self_obj_before;
    PyObject *py_retval;
    
    __py_gil_state = (PyEval_ThreadsInitialized() ? PyGILState_Ensure() : (PyGILState_STATE) 0);
    py_method = PyObject_GetAttrString(m_pyself, (char *) "_NotifyConstructionCompleted"); PyErr_Clear();
    if (py_method == NULL || py_method->ob_type == &PyCFunction_Type) {
        ns3::ObjectBase::NotifyConstructionCompleted();
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
        return;
    }
    self_obj_before = reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj;
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = (ns3::ObjectBase*) this;
    py_retval = PyObject_CallMethod(m_pyself, (char *) "_NotifyConstructionCompleted", (char *) "");
    if (py_retval == NULL) {
        PyErr_Print();
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    if (py_retval != Py_None) {
        PyErr_SetString(PyExc_TypeError, "function/method should return None");
        Py_DECREF(py_retval);
        reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
        Py_XDECREF(py_method);
        if (PyEval_ThreadsInitialized())
            PyGILState_Release(__py_gil_state);
        return;
    }
    Py_DECREF(py_retval);
    reinterpret_cast< PyNs3ObjectBase* >(m_pyself)->obj = self_obj_before;
    Py_XDECREF(py_method);
    if (PyEval_ThreadsInitialized())
        PyGILState_Release(__py_gil_state);
    return;
}


static int
_wrap_PyNs3SingleModelSpectrumChannel__tp_init__0(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyNs3SingleModelSpectrumChannel *arg0;
    const char *keywords[] = {"arg0", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SingleModelSpectrumChannel_Type, &arg0)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SingleModelSpectrumChannel_Type)
    {
        self->obj = new PyNs3SingleModelSpectrumChannel__PythonHelper(*((PyNs3SingleModelSpectrumChannel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SingleModelSpectrumChannel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::SingleModelSpectrumChannel(*((PyNs3SingleModelSpectrumChannel *) arg0)->obj);
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

static int
_wrap_PyNs3SingleModelSpectrumChannel__tp_init__1(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    if (self->ob_type != &PyNs3SingleModelSpectrumChannel_Type)
    {
        self->obj = new PyNs3SingleModelSpectrumChannel__PythonHelper();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ((PyNs3SingleModelSpectrumChannel__PythonHelper*) self->obj)->set_pyobj((PyObject *)self);
        ns3::CompleteConstruct(self->obj);
    } else {
        // visibility: 'public'
        self->obj = new ns3::SingleModelSpectrumChannel();
        self->obj->Ref ();
        self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
        ns3::CompleteConstruct(self->obj);
    }
    return 0;
}

int _wrap_PyNs3SingleModelSpectrumChannel__tp_init(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyNs3SingleModelSpectrumChannel__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyNs3SingleModelSpectrumChannel__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_StartTx(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumSignalParameters *params;
    ns3::SpectrumSignalParameters *params_ptr;
    const char *keywords[] = {"params", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumSignalParameters_Type, &params)) {
        return NULL;
    }
    params_ptr = (params ? params->obj : NULL);
    self->obj->StartTx(ns3::Ptr< ns3::SpectrumSignalParameters  > (params_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_AddPropagationLossModel(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationLossModel *loss;
    ns3::PropagationLossModel *loss_ptr;
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    self->obj->AddPropagationLossModel(ns3::Ptr< ns3::PropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_GetTypeId(void)
{
    PyObject *py_retval;
    PyNs3TypeId *py_TypeId;
    
    ns3::TypeId retval = ns3::SingleModelSpectrumChannel::GetTypeId();
    py_TypeId = PyObject_New(PyNs3TypeId, &PyNs3TypeId_Type);
    py_TypeId->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_TypeId->obj = new ns3::TypeId(retval);
    PyNs3TypeId_wrapper_registry[(void *) py_TypeId->obj] = (PyObject *) py_TypeId;
    py_retval = Py_BuildValue((char *) "N", py_TypeId);
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_GetNDevices(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    uint32_t retval;
    
    retval = self->obj->GetNDevices();
    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(retval));
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_GetSpectrumPropagationLossModel(PyNs3SingleModelSpectrumChannel *self)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::SpectrumPropagationLossModel > retval;
    PyNs3SpectrumPropagationLossModel *py_SpectrumPropagationLossModel;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    retval = self->obj->GetSpectrumPropagationLossModel();
    if (!(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3SpectrumPropagationLossModel__PythonHelper).name())
    {
        py_SpectrumPropagationLossModel = reinterpret_cast< PyNs3SpectrumPropagationLossModel* >(reinterpret_cast< PyNs3SpectrumPropagationLossModel__PythonHelper* >(const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))->m_pyself);
        py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
        Py_INCREF(py_SpectrumPropagationLossModel);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPropagationLossModel = NULL;
        } else {
            py_SpectrumPropagationLossModel = (PyNs3SpectrumPropagationLossModel *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPropagationLossModel);
        }
    
        if (py_SpectrumPropagationLossModel == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval)))), &PyNs3SpectrumPropagationLossModel_Type);
            py_SpectrumPropagationLossModel = PyObject_GC_New(PyNs3SpectrumPropagationLossModel, wrapper_type);
            py_SpectrumPropagationLossModel->inst_dict = NULL;
            py_SpectrumPropagationLossModel->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval))->Ref();
            py_SpectrumPropagationLossModel->obj = const_cast<ns3::SpectrumPropagationLossModel *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPropagationLossModel->obj] = (PyObject *) py_SpectrumPropagationLossModel;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPropagationLossModel);
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_AddSpectrumPropagationLossModel(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPropagationLossModel *loss;
    ns3::SpectrumPropagationLossModel *loss_ptr;
    const char *keywords[] = {"loss", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPropagationLossModel_Type, &loss)) {
        return NULL;
    }
    loss_ptr = (loss ? loss->obj : NULL);
    self->obj->AddSpectrumPropagationLossModel(ns3::Ptr< ns3::SpectrumPropagationLossModel  > (loss_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_SetPropagationDelayModel(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3PropagationDelayModel *delay;
    ns3::PropagationDelayModel *delay_ptr;
    const char *keywords[] = {"delay", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3PropagationDelayModel_Type, &delay)) {
        return NULL;
    }
    delay_ptr = (delay ? delay->obj : NULL);
    self->obj->SetPropagationDelayModel(ns3::Ptr< ns3::PropagationDelayModel  > (delay_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_GetDevice(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    ns3::Ptr< ns3::NetDevice > retval;
    unsigned int i;
    const char *keywords[] = {"i", NULL};
    PyNs3NetDevice *py_NetDevice;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &i)) {
        return NULL;
    }
    retval = self->obj->GetDevice(i);
    if (!(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))).name() == typeid(PyNs3NetDevice__PythonHelper).name())
    {
        py_NetDevice = reinterpret_cast< PyNs3NetDevice* >(reinterpret_cast< PyNs3NetDevice__PythonHelper* >(const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))->m_pyself);
        py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
        Py_INCREF(py_NetDevice);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_NetDevice = NULL;
        } else {
            py_NetDevice = (PyNs3NetDevice *) wrapper_lookup_iter->second;
            Py_INCREF(py_NetDevice);
        }
    
        if (py_NetDevice == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval)))), &PyNs3NetDevice_Type);
            py_NetDevice = PyObject_GC_New(PyNs3NetDevice, wrapper_type);
            py_NetDevice->inst_dict = NULL;
            py_NetDevice->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval))->Ref();
            py_NetDevice->obj = const_cast<ns3::NetDevice *> (ns3::PeekPointer (retval));
            PyNs3ObjectBase_wrapper_registry[(void *) py_NetDevice->obj] = (PyObject *) py_NetDevice;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_NetDevice);
    return py_retval;
}


PyObject *
_wrap_PyNs3SingleModelSpectrumChannel_AddRx(PyNs3SingleModelSpectrumChannel *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *phy;
    ns3::SpectrumPhy *phy_ptr;
    const char *keywords[] = {"phy", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyNs3SpectrumPhy_Type, &phy)) {
        return NULL;
    }
    phy_ptr = (phy ? phy->obj : NULL);
    self->obj->AddRx(ns3::Ptr< ns3::SpectrumPhy  > (phy_ptr));
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


static PyObject*
_wrap_PyNs3SingleModelSpectrumChannel__copy__(PyNs3SingleModelSpectrumChannel *self)
{

    PyNs3SingleModelSpectrumChannel *py_copy;
    py_copy = PyObject_GC_New(PyNs3SingleModelSpectrumChannel, &PyNs3SingleModelSpectrumChannel_Type);
    py_copy->obj = new ns3::SingleModelSpectrumChannel(*self->obj);
    py_copy->inst_dict = NULL;
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    PyNs3ObjectBase_wrapper_registry[(void *) py_copy->obj] = (PyObject *) py_copy;
    return (PyObject*) py_copy;
}

static PyMethodDef PyNs3SingleModelSpectrumChannel_methods[] = {
    {(char *) "StartTx", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_StartTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddPropagationLossModel", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_AddPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetTypeId", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_GetTypeId, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "GetNDevices", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_GetNDevices, METH_NOARGS, NULL },
    {(char *) "GetSpectrumPropagationLossModel", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_GetSpectrumPropagationLossModel, METH_NOARGS, NULL },
    {(char *) "AddSpectrumPropagationLossModel", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_AddSpectrumPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SetPropagationDelayModel", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_SetPropagationDelayModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "GetDevice", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_GetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "AddRx", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel_AddRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyConstructionCompleted", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_NotifyConstructionCompleted, METH_NOARGS, NULL },
    {(char *) "_StartTx", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_StartTx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_AddPropagationLossModel", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_AddPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_NotifyNewAggregate", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_NotifyNewAggregate, METH_NOARGS, NULL },
    {(char *) "_DoStart", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_DoStart, METH_NOARGS, NULL },
    {(char *) "_GetNDevices", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetNDevices, METH_NOARGS, NULL },
    {(char *) "_GetSpectrumPropagationLossModel", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetSpectrumPropagationLossModel, METH_NOARGS, NULL },
    {(char *) "_GetInstanceTypeId", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetInstanceTypeId, METH_NOARGS, NULL },
    {(char *) "_AddSpectrumPropagationLossModel", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_AddSpectrumPropagationLossModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_SetPropagationDelayModel", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_SetPropagationDelayModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_GetDevice", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_GetDevice, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "_AddRx", (PyCFunction) PyNs3SingleModelSpectrumChannel__PythonHelper::_wrap_AddRx, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyNs3SingleModelSpectrumChannel__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
PyNs3SingleModelSpectrumChannel__tp_clear(PyNs3SingleModelSpectrumChannel *self)
{
    Py_CLEAR(self->inst_dict);
    if (self->obj) {
    ns3::SingleModelSpectrumChannel *tmp = self->obj;
    self->obj = NULL;
    tmp->Unref();
}
}


static int
PyNs3SingleModelSpectrumChannel__tp_traverse(PyNs3SingleModelSpectrumChannel *self, visitproc visit, void *arg)
{
    Py_VISIT(self->inst_dict);
    
    if (self->obj && typeid(*self->obj).name() == typeid(PyNs3SingleModelSpectrumChannel__PythonHelper).name()  && self->obj->GetReferenceCount() == 1)
        Py_VISIT((PyObject *) self);

    return 0;
}


static void
_wrap_PyNs3SingleModelSpectrumChannel__tp_dealloc(PyNs3SingleModelSpectrumChannel *self)
{
    std::map<void*, PyObject*>::iterator wrapper_lookup_iter;
    wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) self->obj);
    if (wrapper_lookup_iter != PyNs3ObjectBase_wrapper_registry.end()) {
        PyNs3ObjectBase_wrapper_registry.erase(wrapper_lookup_iter);
    }
    
    PyNs3SingleModelSpectrumChannel__tp_clear(self);
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PyNs3SingleModelSpectrumChannel__tp_richcompare (PyNs3SingleModelSpectrumChannel *PYBINDGEN_UNUSED(self), PyNs3SingleModelSpectrumChannel *other, int opid)
{
    
    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyNs3SingleModelSpectrumChannel_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PyNs3SingleModelSpectrumChannel_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.SingleModelSpectrumChannel",            /* tp_name */
    sizeof(PyNs3SingleModelSpectrumChannel),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyNs3SingleModelSpectrumChannel__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_BASETYPE|Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)PyNs3SingleModelSpectrumChannel__tp_traverse,     /* tp_traverse */
    (inquiry)PyNs3SingleModelSpectrumChannel__tp_clear,             /* tp_clear */
    (richcmpfunc)_wrap_PyNs3SingleModelSpectrumChannel__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyNs3SingleModelSpectrumChannel_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    offsetof(PyNs3SingleModelSpectrumChannel, inst_dict),                 /* tp_dictoffset */
    (initproc)_wrap_PyNs3SingleModelSpectrumChannel__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- containers --- */



static void
Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_clear(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_traverse(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_dealloc(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_dealloc(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_iter(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *self)
{
    Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *iter = PyObject_GC_New(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter, &Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::list< ns3::Ptr< ns3::SpectrumPhy > >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iter(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iternext(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    PyObject *py_retval;
    std::list< ns3::Ptr< ns3::SpectrumPhy > >::iterator iter;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    if (!(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = reinterpret_cast< PyNs3SpectrumPhy* >(reinterpret_cast< PyNs3SpectrumPhy__PythonHelper* >(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter)));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter)))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter)));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPhy);
    return py_retval;
}

int _wrap_convert_py2c__ns3__Ptr__lt___ns3__SpectrumPhy___gt__(PyObject *value, ns3::Ptr< ns3::SpectrumPhy > *address)
{
    PyObject *py_retval;
    PyNs3SpectrumPhy *tmp_SpectrumPhy;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumPhy_Type, &tmp_SpectrumPhy)) {
        Py_DECREF(py_retval);
        return 0;
    }
    // dangerous!
    *address = ns3::Ptr< ns3::SpectrumPhy  > (tmp_SpectrumPhy->obj);
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__(PyObject *arg, std::list< ns3::Ptr< ns3::SpectrumPhy > > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type)) {
        *container = *((Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ns3::Ptr< ns3::SpectrumPhy > item;
            if (!_wrap_convert_py2c__ns3__Ptr__lt___ns3__SpectrumPhy___gt__(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ instance, or a list of ns3::Ptr< ns3::SpectrumPhy >");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_init(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::list< ns3::Ptr< ns3::SpectrumPhy > >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__",            /* tp_name */
    sizeof(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter",            /* tp_name */
    sizeof(Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pyns3__SpectrumConverterMap_tIter__tp_clear(Pyns3__SpectrumConverterMap_tIter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pyns3__SpectrumConverterMap_tIter__tp_traverse(Pyns3__SpectrumConverterMap_tIter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pyns3__SpectrumConverterMap_t__tp_dealloc(Pyns3__SpectrumConverterMap_t *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pyns3__SpectrumConverterMap_tIter__tp_dealloc(Pyns3__SpectrumConverterMap_tIter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pyns3__SpectrumConverterMap_t__tp_iter(Pyns3__SpectrumConverterMap_t *self)
{
    Pyns3__SpectrumConverterMap_tIter *iter = PyObject_GC_New(Pyns3__SpectrumConverterMap_tIter, &Pyns3__SpectrumConverterMap_tIter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new ns3::SpectrumConverterMap_t::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pyns3__SpectrumConverterMap_tIter__tp_iter(Pyns3__SpectrumConverterMap_tIter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pyns3__SpectrumConverterMap_tIter__tp_iternext(Pyns3__SpectrumConverterMap_tIter *self)
{
    PyObject *py_retval;
    ns3::SpectrumConverterMap_t::iterator iter;
    PyNs3SpectrumConverter *py_SpectrumConverter;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_SpectrumConverter = PyObject_New(PyNs3SpectrumConverter, &PyNs3SpectrumConverter_Type);
    py_SpectrumConverter->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SpectrumConverter->obj = new ns3::SpectrumConverter(iter->second);
    PyNs3Empty_wrapper_registry[(void *) py_SpectrumConverter->obj] = (PyObject *) py_SpectrumConverter;
    py_retval = Py_BuildValue((char *) "NN", PyLong_FromUnsignedLong(iter->first), py_SpectrumConverter);
    return py_retval;
}

int _wrap_convert_py2c__ns3__SpectrumConverter(PyObject *value, ns3::SpectrumConverter *address)
{
    PyObject *py_retval;
    PyNs3SpectrumConverter *tmp_SpectrumConverter;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3SpectrumConverter_Type, &tmp_SpectrumConverter)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_SpectrumConverter->obj;
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__unsigned_int(PyObject *value, unsigned int *address)
{
    PyObject *py_retval;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &*address)) {
        Py_DECREF(py_retval);
        return 0;
    }
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__ns3__SpectrumConverterMap_t(PyObject *arg, ns3::SpectrumConverterMap_t *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pyns3__SpectrumConverterMap_t_Type)) {
        *container = *((Pyns3__SpectrumConverterMap_t*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            PyObject *tup = PyList_GET_ITEM(arg, i);
            if (!PyTuple_Check(tup) || PyTuple_Size(tup) != 2) {
                PyErr_SetString(PyExc_TypeError, "items must be tuples with two elements");
                return 0;
            }
            std::pair<unsigned int, ns3::SpectrumConverter> item;
            if (!_wrap_convert_py2c__unsigned_int(PyTuple_GET_ITEM(tup, 0), &item.first)) {
                return 0;
            }
            if (!_wrap_convert_py2c__ns3__SpectrumConverter(PyTuple_GET_ITEM(tup, 1), &item.second)) {
                return 0;
            }
            container->insert(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Ns3__SpectrumConverterMap_t instance, or a list of ns3::SpectrumConverter");
        return 0;
    }
    return 1;
}


static int
_wrap_Pyns3__SpectrumConverterMap_t__tp_init(Pyns3__SpectrumConverterMap_t *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new ns3::SpectrumConverterMap_t;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__ns3__SpectrumConverterMap_t(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pyns3__SpectrumConverterMap_t_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Ns3__SpectrumConverterMap_t",            /* tp_name */
    sizeof(Pyns3__SpectrumConverterMap_t),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pyns3__SpectrumConverterMap_t__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pyns3__SpectrumConverterMap_t__tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pyns3__SpectrumConverterMap_t__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pyns3__SpectrumConverterMap_tIter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Ns3__SpectrumConverterMap_tIter",            /* tp_name */
    sizeof(Pyns3__SpectrumConverterMap_tIter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pyns3__SpectrumConverterMap_tIter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pyns3__SpectrumConverterMap_tIter__tp_traverse,     /* tp_traverse */
    (inquiry)Pyns3__SpectrumConverterMap_tIter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pyns3__SpectrumConverterMap_tIter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pyns3__SpectrumConverterMap_tIter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__vector__lt___double___gt__Iter__tp_clear(Pystd__vector__lt___double___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt___double___gt__Iter__tp_traverse(Pystd__vector__lt___double___gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt___double___gt____tp_dealloc(Pystd__vector__lt___double___gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt___double___gt__Iter__tp_dealloc(Pystd__vector__lt___double___gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt___double___gt____tp_iter(Pystd__vector__lt___double___gt__ *self)
{
    Pystd__vector__lt___double___gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt___double___gt__Iter, &Pystd__vector__lt___double___gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector< double >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt___double___gt__Iter__tp_iter(Pystd__vector__lt___double___gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt___double___gt__Iter__tp_iternext(Pystd__vector__lt___double___gt__Iter *self)
{
    PyObject *py_retval;
    std::vector< double >::iterator iter;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "d", (*iter));
    return py_retval;
}

int _wrap_convert_py2c__std__vector__lt___double___gt__(PyObject *arg, std::vector< double > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt___double___gt___Type)) {
        *container = *((Pystd__vector__lt___double___gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            double item;
            if (!_wrap_convert_py2c__double(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt___double___gt__ instance, or a list of double");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt___double___gt____tp_init(Pystd__vector__lt___double___gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector< double >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___double___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt___double___gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Std__vector__lt___double___gt__",            /* tp_name */
    sizeof(Pystd__vector__lt___double___gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___double___gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___double___gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt___double___gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt___double___gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Std__vector__lt___double___gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt___double___gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___double___gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt___double___gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt___double___gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___double___gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt___double___gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pyns3__BandsIter__tp_clear(Pyns3__BandsIter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pyns3__BandsIter__tp_traverse(Pyns3__BandsIter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pyns3__Bands__tp_dealloc(Pyns3__Bands *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pyns3__BandsIter__tp_dealloc(Pyns3__BandsIter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pyns3__Bands__tp_iter(Pyns3__Bands *self)
{
    Pyns3__BandsIter *iter = PyObject_GC_New(Pyns3__BandsIter, &Pyns3__BandsIter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new ns3::Bands::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pyns3__BandsIter__tp_iter(Pyns3__BandsIter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pyns3__BandsIter__tp_iternext(Pyns3__BandsIter *self)
{
    PyObject *py_retval;
    ns3::Bands::iterator iter;
    PyNs3BandInfo *py_BandInfo;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_BandInfo = PyObject_New(PyNs3BandInfo, &PyNs3BandInfo_Type);
    py_BandInfo->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_BandInfo->obj = new ns3::BandInfo((*iter));
    PyNs3BandInfo_wrapper_registry[(void *) py_BandInfo->obj] = (PyObject *) py_BandInfo;
    py_retval = Py_BuildValue((char *) "N", py_BandInfo);
    return py_retval;
}

int _wrap_convert_py2c__ns3__BandInfo(PyObject *value, ns3::BandInfo *address)
{
    PyObject *py_retval;
    PyNs3BandInfo *tmp_BandInfo;
    
    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyNs3BandInfo_Type, &tmp_BandInfo)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_BandInfo->obj;
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__ns3__Bands(PyObject *arg, ns3::Bands *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pyns3__Bands_Type)) {
        *container = *((Pyns3__Bands*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ns3::BandInfo item;
            if (!_wrap_convert_py2c__ns3__BandInfo(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Ns3__Bands instance, or a list of ns3::BandInfo");
        return 0;
    }
    return 1;
}


static int
_wrap_Pyns3__Bands__tp_init(Pyns3__Bands *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new ns3::Bands;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__ns3__Bands(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pyns3__Bands_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Ns3__Bands",            /* tp_name */
    sizeof(Pyns3__Bands),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pyns3__Bands__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pyns3__Bands__tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pyns3__Bands__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pyns3__BandsIter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Ns3__BandsIter",            /* tp_name */
    sizeof(Pyns3__BandsIter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pyns3__BandsIter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pyns3__BandsIter__tp_traverse,     /* tp_traverse */
    (inquiry)Pyns3__BandsIter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pyns3__BandsIter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pyns3__BandsIter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_clear(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_traverse(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_dealloc(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_dealloc(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_iter(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *self)
{
    Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter, &Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector< ns3::Ptr< ns3::SpectrumPhy > >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iter(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iternext(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter *self)
{
    PyObject *py_retval;
    std::vector< ns3::Ptr< ns3::SpectrumPhy > >::iterator iter;
    PyNs3SpectrumPhy *py_SpectrumPhy;
    std::map<void*, PyObject*>::const_iterator wrapper_lookup_iter;
    PyTypeObject *wrapper_type = 0;
    
    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    if (!(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    if (typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))).name() == typeid(PyNs3SpectrumPhy__PythonHelper).name())
    {
        py_SpectrumPhy = reinterpret_cast< PyNs3SpectrumPhy* >(reinterpret_cast< PyNs3SpectrumPhy__PythonHelper* >(const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))->m_pyself);
        py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter)));
        Py_INCREF(py_SpectrumPhy);
    } else {
        wrapper_lookup_iter = PyNs3ObjectBase_wrapper_registry.find((void *) const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))));
        if (wrapper_lookup_iter == PyNs3ObjectBase_wrapper_registry.end()) {
            py_SpectrumPhy = NULL;
        } else {
            py_SpectrumPhy = (PyNs3SpectrumPhy *) wrapper_lookup_iter->second;
            Py_INCREF(py_SpectrumPhy);
        }
    
        if (py_SpectrumPhy == NULL) {
            wrapper_type = PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.lookup_wrapper(typeid((*const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter))))), &PyNs3SpectrumPhy_Type);
            py_SpectrumPhy = PyObject_GC_New(PyNs3SpectrumPhy, wrapper_type);
            py_SpectrumPhy->inst_dict = NULL;
            py_SpectrumPhy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
            const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter)))->Ref();
            py_SpectrumPhy->obj = const_cast<ns3::SpectrumPhy *> (ns3::PeekPointer ((*iter)));
            PyNs3ObjectBase_wrapper_registry[(void *) py_SpectrumPhy->obj] = (PyObject *) py_SpectrumPhy;
        }
    }
    py_retval = Py_BuildValue((char *) "N", py_SpectrumPhy);
    return py_retval;
}

int _wrap_convert_py2c__std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__(PyObject *arg, std::vector< ns3::Ptr< ns3::SpectrumPhy > > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type)) {
        *container = *((Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ns3::Ptr< ns3::SpectrumPhy > item;
            if (!_wrap_convert_py2c__ns3__Ptr__lt___ns3__SpectrumPhy___gt__(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ instance, or a list of ns3::Ptr< ns3::SpectrumPhy >");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_init(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector< ns3::Ptr< ns3::SpectrumPhy > >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__",            /* tp_name */
    sizeof(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "spectrum.Std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- enumerations --- */

















PyMODINIT_FUNC
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif
initspectrum(void)
{
    PyObject *m;
    PyObject *submodule;
    m = Py_InitModule3((char *) "spectrum", spectrum_functions, NULL);
    if (m == NULL) {
        return;
    }
    PyModule_AddIntConstant(m, (char *) "STD_IOS_IN", std::ios::in);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_OUT", std::ios::out);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_ATE", std::ios::ate);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_APP", std::ios::app);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_TRUNC", std::ios::trunc);
    PyModule_AddIntConstant(m, (char *) "STD_IOS_BINARY", std::ios::binary);
    /* Import the 'ns3::Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::AttributeConstructionList' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeConstructionList_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AttributeConstructionList");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3AttributeConstructionList_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3AttributeConstructionList_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3AttributeConstructionList_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::AttributeConstructionList::Item' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeConstructionListItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3AttributeConstructionListItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3AttributeConstructionListItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3AttributeConstructionListItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Buffer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Buffer_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Buffer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Buffer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Buffer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Buffer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Buffer::Iterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3BufferIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Iterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3BufferIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3BufferIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3BufferIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagIterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ByteTagIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ByteTagIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagIterator::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagIteratorItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ByteTagIteratorItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagIteratorItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagIteratorItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagList' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagList_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ByteTagList");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ByteTagList_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagList_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagList_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagList::Iterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagListIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Iterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ByteTagListIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagListIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagListIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ByteTagList::Iterator::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3ByteTagListIteratorItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ByteTagListIteratorItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ByteTagListIteratorItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ByteTagListIteratorItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::CallbackBase' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackBase_Type = (PyTypeObject*) PyObject_GetAttrString(module, "CallbackBase");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3CallbackBase_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3CallbackBase_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3CallbackBase_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::DataRate' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3DataRate_Type = (PyTypeObject*) PyObject_GetAttrString(module, "DataRate");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3DataRate_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3DataRate_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3DataRate_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::EventId' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EventId_Type = (PyTypeObject*) PyObject_GetAttrString(module, "EventId");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3EventId_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3EventId_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3EventId_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv4Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv4Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Ipv4Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv4Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv4Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv4Mask' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4Mask_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv4Mask");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Ipv4Mask_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv4Mask_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv4Mask_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv6Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv6Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Ipv6Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv6Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv6Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Ipv6Prefix' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6Prefix_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv6Prefix");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Ipv6Prefix_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Ipv6Prefix_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Ipv6Prefix_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Mac48Address' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Mac48Address_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Mac48Address");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Mac48Address_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Mac48Address_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Mac48Address_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::NetDeviceContainer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NetDeviceContainer_Type = (PyTypeObject*) PyObject_GetAttrString(module, "NetDeviceContainer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3NetDeviceContainer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3NetDeviceContainer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3NetDeviceContainer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::NodeContainer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NodeContainer_Type = (PyTypeObject*) PyObject_GetAttrString(module, "NodeContainer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3NodeContainer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3NodeContainer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3NodeContainer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ObjectBase' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectBase_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ObjectBase");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ObjectBase_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectBase_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectBase_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ObjectDeleter' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectDeleter_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ObjectDeleter");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ObjectDeleter_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectDeleter_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectDeleter_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ObjectFactory' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectFactory_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ObjectFactory");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ObjectFactory_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectFactory_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectFactory_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketMetadata' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketMetadata_Type = (PyTypeObject*) PyObject_GetAttrString(module, "PacketMetadata");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketMetadata_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketMetadata_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketMetadata_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketMetadata::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketMetadataItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketMetadataItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketMetadataItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketMetadataItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketMetadata::ItemIterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketMetadataItemIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ItemIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketMetadataItemIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketMetadataItemIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketMetadataItemIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagIterator' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, "PacketTagIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketTagIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagIterator::Item' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagIteratorItem_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Item");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketTagIteratorItem_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagIteratorItem_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagIteratorItem_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagList' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagList_Type = (PyTypeObject*) PyObject_GetAttrString(module, "PacketTagList");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketTagList_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagList_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagList_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::PacketTagList::TagData' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3PacketTagListTagData_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TagData");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3PacketTagListTagData_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3PacketTagListTagData_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3PacketTagListTagData_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::RandomVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3RandomVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "RandomVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3RandomVariable_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3RandomVariable_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3RandomVariable_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SeedManager' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SeedManager_Type = (PyTypeObject*) PyObject_GetAttrString(module, "SeedManager");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SeedManager_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3SeedManager_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3SeedManager_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SequentialVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SequentialVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "SequentialVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SystemWallClockMs' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SystemWallClockMs_Type = (PyTypeObject*) PyObject_GetAttrString(module, "SystemWallClockMs");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SystemWallClockMs_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3SystemWallClockMs_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3SystemWallClockMs_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Tag' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Tag_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Tag");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TagBuffer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3TagBuffer_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TagBuffer");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3TagBuffer_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TagBuffer_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TagBuffer_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TriangularVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TriangularVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TriangularVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TypeId' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeId_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TypeId");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3TypeId_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TypeId_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TypeId_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TypeId::AttributeInformation' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdAttributeInformation_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AttributeInformation");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3TypeIdAttributeInformation_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TypeIdAttributeInformation_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TypeIdAttributeInformation_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TypeId::TraceSourceInformation' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdTraceSourceInformation_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TraceSourceInformation");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3TypeIdTraceSourceInformation_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3TypeIdTraceSourceInformation_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3TypeIdTraceSourceInformation_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::UniformVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3UniformVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "UniformVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Vector2D' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Vector2D_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Vector2D");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Vector2D_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Vector2D_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Vector2D_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Vector3D' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Vector3D_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Vector3D");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Vector3D_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Vector3D_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Vector3D_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::WeibullVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3WeibullVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "WeibullVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ZetaVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ZetaVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ZetaVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ZipfVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ZipfVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ZipfVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::empty' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Empty_Type = (PyTypeObject*) PyObject_GetAttrString(module, "empty");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Empty_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Empty_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Empty_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::int64x64_t' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Int64x64_t_Type = (PyTypeObject*) PyObject_GetAttrString(module, "int64x64_t");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Int64x64_t_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Int64x64_t_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Int64x64_t_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::Chunk' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Chunk_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Chunk");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ConstantVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ConstantVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ConstantVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::DeterministicVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3DeterministicVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "DeterministicVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::EmpiricalVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EmpiricalVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "EmpiricalVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ErlangVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ErlangVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ErlangVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ExponentialVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ExponentialVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ExponentialVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::GammaVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3GammaVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "GammaVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Header' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Header_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Header");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::IntEmpiricalVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3IntEmpiricalVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "IntEmpiricalVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::LogNormalVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3LogNormalVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "LogNormalVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NormalVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3NormalVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "NormalVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Object' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Object_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Object");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Object::AggregateIterator' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectAggregateIterator_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AggregateIterator");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3ObjectAggregateIterator_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3ObjectAggregateIterator_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3ObjectAggregateIterator_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ParetoVariable' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ParetoVariable_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ParetoVariable");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::PropagationDelayModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3PropagationDelayModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "PropagationDelayModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::PropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3PropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "PropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Queue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Queue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Queue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::RandomPropagationDelayModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3RandomPropagationDelayModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "RandomPropagationDelayModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::RandomPropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3RandomPropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "RandomPropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::RangePropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3RangePropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "RangePropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___Type = (PyTypeObject*) PyObject_GetAttrString(module, "SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt__");
    
        if (PyErr_Occurred()) PyErr_Clear();
        /* Import the 'ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >' class type map from module 'ns.core' */
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map");
        if (_cobj == NULL) {
            _PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map = new pybindgen::TypeMap;
            PyErr_Clear();
        } else {
            _PyNs3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt____typeid_map = reinterpret_cast<pybindgen::TypeMap*> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::ThreeLogDistancePropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3ThreeLogDistancePropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ThreeLogDistancePropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Time' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Time_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Time");
    
        if (PyErr_Occurred()) PyErr_Clear();
        PyObject *_cobj = PyObject_GetAttrString(module, "_PyNs3Time_wrapper_registry");
        if (_cobj == NULL) {
            _PyNs3Time_wrapper_registry = NULL;
            PyErr_Clear();
        } else {
            _PyNs3Time_wrapper_registry = reinterpret_cast< std::map<void*, PyObject*> *> (PyCObject_AsVoidPtr (_cobj));
            Py_DECREF(_cobj);
        }
    }
    /* Import the 'ns3::TraceSourceAccessor' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TraceSourceAccessor_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TraceSourceAccessor");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Trailer' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Trailer_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Trailer");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TwoRayGroundPropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3TwoRayGroundPropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TwoRayGroundPropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AttributeAccessor' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeAccessor_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AttributeAccessor");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AttributeChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AttributeChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AttributeValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3AttributeValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AttributeValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::CallbackChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "CallbackChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::CallbackImplBase' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackImplBase_Type = (PyTypeObject*) PyObject_GetAttrString(module, "CallbackImplBase");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::CallbackValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3CallbackValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "CallbackValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Channel' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Channel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Channel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ConstantSpeedPropagationDelayModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3ConstantSpeedPropagationDelayModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ConstantSpeedPropagationDelayModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::DataRateChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3DataRateChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "DataRateChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::DataRateValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3DataRateValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "DataRateValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::EmptyAttributeValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EmptyAttributeValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "EmptyAttributeValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::EventImpl' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3EventImpl_Type = (PyTypeObject*) PyObject_GetAttrString(module, "EventImpl");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::FixedRssLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3FixedRssLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "FixedRssLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::FriisPropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3FriisPropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "FriisPropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv4AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv4AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4MaskChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4MaskChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv4MaskChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv4MaskValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv4MaskValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv4MaskValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv6AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv6AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6PrefixChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6PrefixChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv6PrefixChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Ipv6PrefixValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Ipv6PrefixValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Ipv6PrefixValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::LogDistancePropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3LogDistancePropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "LogDistancePropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Mac48AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Mac48AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Mac48AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Mac48AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Mac48AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Mac48AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::MatrixPropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3MatrixPropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "MatrixPropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::MobilityModel' class from module 'ns.mobility' */
    {
        PyObject *module = PyImport_ImportModule("ns.mobility");
        if (module == NULL) {
            return ;
        }
        _PyNs3MobilityModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "MobilityModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NakagamiPropagationLossModel' class from module 'ns.propagation' */
    {
        PyObject *module = PyImport_ImportModule("ns.propagation");
        if (module == NULL) {
            return ;
        }
        _PyNs3NakagamiPropagationLossModel_Type = (PyTypeObject*) PyObject_GetAttrString(module, "NakagamiPropagationLossModel");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NetDevice' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NetDevice_Type = (PyTypeObject*) PyObject_GetAttrString(module, "NetDevice");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::NixVector' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3NixVector_Type = (PyTypeObject*) PyObject_GetAttrString(module, "NixVector");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Node' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Node_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Node");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ObjectFactoryChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectFactoryChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ObjectFactoryChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::ObjectFactoryValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3ObjectFactoryValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "ObjectFactoryValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Packet' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3Packet_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Packet");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::RandomVariableChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3RandomVariableChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "RandomVariableChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::RandomVariableValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3RandomVariableValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "RandomVariableValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TimeChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TimeChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TimeChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TimeValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TimeValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TimeValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TypeIdChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TypeIdChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::TypeIdValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3TypeIdValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "TypeIdValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Vector2DChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Vector2DChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Vector2DChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Vector2DValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Vector2DValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Vector2DValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Vector3DChecker' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Vector3DChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Vector3DChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::Vector3DValue' class from module 'ns.core' */
    {
        PyObject *module = PyImport_ImportModule("ns.core");
        if (module == NULL) {
            return ;
        }
        _PyNs3Vector3DValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "Vector3DValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AddressChecker' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3AddressChecker_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AddressChecker");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    /* Import the 'ns3::AddressValue' class from module 'ns.network' */
    {
        PyObject *module = PyImport_ImportModule("ns.network");
        if (module == NULL) {
            return ;
        }
        _PyNs3AddressValue_Type = (PyTypeObject*) PyObject_GetAttrString(module, "AddressValue");
    
        if (PyErr_Occurred()) PyErr_Clear();
    }
    PyModule_AddObject(m, (char *) "_PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3AdhocAlohaNoackIdealPhyHelper_wrapper_registry, NULL));
    /* Register the 'ns3::AdhocAlohaNoackIdealPhyHelper' class */
    if (PyType_Ready(&PyNs3AdhocAlohaNoackIdealPhyHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "AdhocAlohaNoackIdealPhyHelper", (PyObject *) &PyNs3AdhocAlohaNoackIdealPhyHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3BandInfo_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3BandInfo_wrapper_registry, NULL));
    /* Register the 'ns3::BandInfo' class */
    if (PyType_Ready(&PyNs3BandInfo_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "BandInfo", (PyObject *) &PyNs3BandInfo_Type);
    PyModule_AddObject(m, (char *) "_PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3MicrowaveOvenSpectrumValueHelper_wrapper_registry, NULL));
    /* Register the 'ns3::MicrowaveOvenSpectrumValueHelper' class */
    if (PyType_Ready(&PyNs3MicrowaveOvenSpectrumValueHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "MicrowaveOvenSpectrumValueHelper", (PyObject *) &PyNs3MicrowaveOvenSpectrumValueHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3RxSpectrumModelInfo_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3RxSpectrumModelInfo_wrapper_registry, NULL));
    /* Register the 'ns3::RxSpectrumModelInfo' class */
    if (PyType_Ready(&PyNs3RxSpectrumModelInfo_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "RxSpectrumModelInfo", (PyObject *) &PyNs3RxSpectrumModelInfo_Type);
    PyModule_AddObject(m, (char *) "_PyNs3SpectrumAnalyzerHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3SpectrumAnalyzerHelper_wrapper_registry, NULL));
    /* Register the 'ns3::SpectrumAnalyzerHelper' class */
    if (PyType_Ready(&PyNs3SpectrumAnalyzerHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumAnalyzerHelper", (PyObject *) &PyNs3SpectrumAnalyzerHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3SpectrumChannelHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3SpectrumChannelHelper_wrapper_registry, NULL));
    /* Register the 'ns3::SpectrumChannelHelper' class */
    if (PyType_Ready(&PyNs3SpectrumChannelHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumChannelHelper", (PyObject *) &PyNs3SpectrumChannelHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3SpectrumPhyHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3SpectrumPhyHelper_wrapper_registry, NULL));
    /* Register the 'ns3::SpectrumPhyHelper' class */
    if (PyType_Ready(&PyNs3SpectrumPhyHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumPhyHelper", (PyObject *) &PyNs3SpectrumPhyHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3TxSpectrumModelInfo_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3TxSpectrumModelInfo_wrapper_registry, NULL));
    /* Register the 'ns3::TxSpectrumModelInfo' class */
    if (PyType_Ready(&PyNs3TxSpectrumModelInfo_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "TxSpectrumModelInfo", (PyObject *) &PyNs3TxSpectrumModelInfo_Type);
    PyModule_AddObject(m, (char *) "_PyNs3WaveformGeneratorHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3WaveformGeneratorHelper_wrapper_registry, NULL));
    /* Register the 'ns3::WaveformGeneratorHelper' class */
    if (PyType_Ready(&PyNs3WaveformGeneratorHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "WaveformGeneratorHelper", (PyObject *) &PyNs3WaveformGeneratorHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3WifiSpectrumValue5MhzFactory_wrapper_registry, NULL));
    /* Register the 'ns3::WifiSpectrumValue5MhzFactory' class */
    if (PyType_Ready(&PyNs3WifiSpectrumValue5MhzFactory_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "WifiSpectrumValue5MhzFactory", (PyObject *) &PyNs3WifiSpectrumValue5MhzFactory_Type);
    PyModule_AddObject(m, (char *) "_PyNs3WifiSpectrumValueHelper_wrapper_registry", PyCObject_FromVoidPtr(&PyNs3WifiSpectrumValueHelper_wrapper_registry, NULL));
    /* Register the 'ns3::WifiSpectrumValueHelper' class */
    if (PyType_Ready(&PyNs3WifiSpectrumValueHelper_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "WifiSpectrumValueHelper", (PyObject *) &PyNs3WifiSpectrumValueHelper_Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> >), &PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::SpectrumConverter, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumConverter> >' class */
    PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >), &PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >' class */
    PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >), &PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >' class */
    PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type);
    PyModule_AddObject(m, (char *) "_PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map", PyCObject_FromVoidPtr(&PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map, NULL));
    PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.register_wrapper(typeid(ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >), &PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type);
    /* Register the 'ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >' class */
    PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type.tp_base = &PyNs3Empty_Type;
    if (PyType_Ready(&PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt__", (PyObject *) &PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type);
    PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt____typeid_map.register_wrapper(typeid(ns3::SpectrumConverter), &PyNs3SpectrumConverter_Type);
    /* Register the 'ns3::SpectrumConverter' class */
    PyNs3SpectrumConverter_Type.tp_base = &PyNs3SimpleRefCount__Ns3SpectrumConverter_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumConverter__gt___Type;
    if (PyType_Ready(&PyNs3SpectrumConverter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumConverter", (PyObject *) &PyNs3SpectrumConverter_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SpectrumErrorModel), &PyNs3SpectrumErrorModel_Type);
    /* Register the 'ns3::SpectrumErrorModel' class */
    PyNs3SpectrumErrorModel_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3SpectrumErrorModel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumErrorModel", (PyObject *) &PyNs3SpectrumErrorModel_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SpectrumInterference), &PyNs3SpectrumInterference_Type);
    /* Register the 'ns3::SpectrumInterference' class */
    PyNs3SpectrumInterference_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3SpectrumInterference_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumInterference", (PyObject *) &PyNs3SpectrumInterference_Type);
    PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt____typeid_map.register_wrapper(typeid(ns3::SpectrumModel), &PyNs3SpectrumModel_Type);
    /* Register the 'ns3::SpectrumModel' class */
    PyNs3SpectrumModel_Type.tp_base = &PyNs3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___Type;
    if (PyType_Ready(&PyNs3SpectrumModel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumModel", (PyObject *) &PyNs3SpectrumModel_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SpectrumPhy), &PyNs3SpectrumPhy_Type);
    /* Register the 'ns3::SpectrumPhy' class */
    PyNs3SpectrumPhy_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3SpectrumPhy_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumPhy", (PyObject *) &PyNs3SpectrumPhy_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SpectrumPropagationLossModel), &PyNs3SpectrumPropagationLossModel_Type);
    /* Register the 'ns3::SpectrumPropagationLossModel' class */
    PyNs3SpectrumPropagationLossModel_Type.tp_base = &PyNs3Object_Type;
    if (PyType_Ready(&PyNs3SpectrumPropagationLossModel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumPropagationLossModel", (PyObject *) &PyNs3SpectrumPropagationLossModel_Type);
    PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.register_wrapper(typeid(ns3::SpectrumSignalParameters), &PyNs3SpectrumSignalParameters_Type);
    /* Register the 'ns3::SpectrumSignalParameters' class */
    PyNs3SpectrumSignalParameters_Type.tp_base = &PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___Type;
    if (PyType_Ready(&PyNs3SpectrumSignalParameters_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumSignalParameters", (PyObject *) &PyNs3SpectrumSignalParameters_Type);
    PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt____typeid_map.register_wrapper(typeid(ns3::SpectrumValue), &PyNs3SpectrumValue_Type);
    /* Register the 'ns3::SpectrumValue' class */
    PyNs3SpectrumValue_Type.tp_base = &PyNs3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___Type;
    if (PyType_Ready(&PyNs3SpectrumValue_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumValue", (PyObject *) &PyNs3SpectrumValue_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::WaveformGenerator), &PyNs3WaveformGenerator_Type);
    /* Register the 'ns3::WaveformGenerator' class */
    PyNs3WaveformGenerator_Type.tp_base = &PyNs3SpectrumPhy_Type;
    if (PyType_Ready(&PyNs3WaveformGenerator_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "WaveformGenerator", (PyObject *) &PyNs3WaveformGenerator_Type);
    /* Register the 'ns3::AlohaNoackMacHeader' class */
    PyNs3AlohaNoackMacHeader_Type.tp_base = &PyNs3Header_Type;
    if (PyType_Ready(&PyNs3AlohaNoackMacHeader_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "AlohaNoackMacHeader", (PyObject *) &PyNs3AlohaNoackMacHeader_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::FriisSpectrumPropagationLossModel), &PyNs3FriisSpectrumPropagationLossModel_Type);
    /* Register the 'ns3::FriisSpectrumPropagationLossModel' class */
    PyNs3FriisSpectrumPropagationLossModel_Type.tp_base = &PyNs3SpectrumPropagationLossModel_Type;
    if (PyType_Ready(&PyNs3FriisSpectrumPropagationLossModel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "FriisSpectrumPropagationLossModel", (PyObject *) &PyNs3FriisSpectrumPropagationLossModel_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::HalfDuplexIdealPhy), &PyNs3HalfDuplexIdealPhy_Type);
    /* Register the 'ns3::HalfDuplexIdealPhy' class */
    PyNs3HalfDuplexIdealPhy_Type.tp_base = &PyNs3SpectrumPhy_Type;
    if (PyType_Ready(&PyNs3HalfDuplexIdealPhy_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "HalfDuplexIdealPhy", (PyObject *) &PyNs3HalfDuplexIdealPhy_Type);
    PyNs3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt____typeid_map.register_wrapper(typeid(ns3::HalfDuplexIdealPhySignalParameters), &PyNs3HalfDuplexIdealPhySignalParameters_Type);
    /* Register the 'ns3::HalfDuplexIdealPhySignalParameters' class */
    PyNs3HalfDuplexIdealPhySignalParameters_Type.tp_base = &PyNs3SpectrumSignalParameters_Type;
    if (PyType_Ready(&PyNs3HalfDuplexIdealPhySignalParameters_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "HalfDuplexIdealPhySignalParameters", (PyObject *) &PyNs3HalfDuplexIdealPhySignalParameters_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::NonCommunicatingNetDevice), &PyNs3NonCommunicatingNetDevice_Type);
    /* Register the 'ns3::NonCommunicatingNetDevice' class */
    PyNs3NonCommunicatingNetDevice_Type.tp_base = &PyNs3NetDevice_Type;
    if (PyType_Ready(&PyNs3NonCommunicatingNetDevice_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "NonCommunicatingNetDevice", (PyObject *) &PyNs3NonCommunicatingNetDevice_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::ShannonSpectrumErrorModel), &PyNs3ShannonSpectrumErrorModel_Type);
    /* Register the 'ns3::ShannonSpectrumErrorModel' class */
    PyNs3ShannonSpectrumErrorModel_Type.tp_base = &PyNs3SpectrumErrorModel_Type;
    if (PyType_Ready(&PyNs3ShannonSpectrumErrorModel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "ShannonSpectrumErrorModel", (PyObject *) &PyNs3ShannonSpectrumErrorModel_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SpectrumAnalyzer), &PyNs3SpectrumAnalyzer_Type);
    /* Register the 'ns3::SpectrumAnalyzer' class */
    PyNs3SpectrumAnalyzer_Type.tp_base = &PyNs3SpectrumPhy_Type;
    if (PyType_Ready(&PyNs3SpectrumAnalyzer_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumAnalyzer", (PyObject *) &PyNs3SpectrumAnalyzer_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SpectrumChannel), &PyNs3SpectrumChannel_Type);
    /* Register the 'ns3::SpectrumChannel' class */
    PyNs3SpectrumChannel_Type.tp_base = &PyNs3Channel_Type;
    if (PyType_Ready(&PyNs3SpectrumChannel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SpectrumChannel", (PyObject *) &PyNs3SpectrumChannel_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::AlohaNoackNetDevice), &PyNs3AlohaNoackNetDevice_Type);
    /* Register the 'ns3::AlohaNoackNetDevice' class */
    PyNs3AlohaNoackNetDevice_Type.tp_base = &PyNs3NetDevice_Type;
    if (PyType_Ready(&PyNs3AlohaNoackNetDevice_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "AlohaNoackNetDevice", (PyObject *) &PyNs3AlohaNoackNetDevice_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::MultiModelSpectrumChannel), &PyNs3MultiModelSpectrumChannel_Type);
    /* Register the 'ns3::MultiModelSpectrumChannel' class */
    PyNs3MultiModelSpectrumChannel_Type.tp_base = &PyNs3SpectrumChannel_Type;
    if (PyType_Ready(&PyNs3MultiModelSpectrumChannel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "MultiModelSpectrumChannel", (PyObject *) &PyNs3MultiModelSpectrumChannel_Type);
    PyNs3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter__typeid_map.register_wrapper(typeid(ns3::SingleModelSpectrumChannel), &PyNs3SingleModelSpectrumChannel_Type);
    /* Register the 'ns3::SingleModelSpectrumChannel' class */
    PyNs3SingleModelSpectrumChannel_Type.tp_base = &PyNs3SpectrumChannel_Type;
    if (PyType_Ready(&PyNs3SingleModelSpectrumChannel_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SingleModelSpectrumChannel", (PyObject *) &PyNs3SingleModelSpectrumChannel_Type);
    /* Register the 'std::list< ns3::Ptr< ns3::SpectrumPhy > >' class */
    if (PyType_Ready(&Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__", (PyObject *) &Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type);
    PyModule_AddObject(m, (char *) "Std__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter", (PyObject *) &Pystd__list__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type);
    /* Register the 'ns3::SpectrumConverterMap_t' class */
    if (PyType_Ready(&Pyns3__SpectrumConverterMap_t_Type)) {
        return;
    }
    if (PyType_Ready(&Pyns3__SpectrumConverterMap_tIter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ns3__SpectrumConverterMap_t", (PyObject *) &Pyns3__SpectrumConverterMap_t_Type);
    PyModule_AddObject(m, (char *) "Ns3__SpectrumConverterMap_tIter", (PyObject *) &Pyns3__SpectrumConverterMap_tIter_Type);
    /* Register the 'std::vector< double >' class */
    if (PyType_Ready(&Pystd__vector__lt___double___gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__vector__lt___double___gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt___double___gt__", (PyObject *) &Pystd__vector__lt___double___gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt___double___gt__Iter", (PyObject *) &Pystd__vector__lt___double___gt__Iter_Type);
    /* Register the 'ns3::Bands' class */
    if (PyType_Ready(&Pyns3__Bands_Type)) {
        return;
    }
    if (PyType_Ready(&Pyns3__BandsIter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Ns3__Bands", (PyObject *) &Pyns3__Bands_Type);
    PyModule_AddObject(m, (char *) "Ns3__BandsIter", (PyObject *) &Pyns3__BandsIter_Type);
    /* Register the 'std::vector< ns3::Ptr< ns3::SpectrumPhy > >' class */
    if (PyType_Ready(&Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__", (PyObject *) &Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter", (PyObject *) &Pystd__vector__lt___ns3__Ptr__lt___ns3__SpectrumPhy___gt_____gt__Iter_Type);
    PyModule_AddObject(m, (char *) "VectorValue", (PyObject *) &PyNs3Vector3DValue_Type);
    PyModule_AddObject(m, (char *) "Vector", (PyObject *) &PyNs3Vector3D_Type);
    PyModule_AddObject(m, (char *) "VectorChecker", (PyObject *) &PyNs3Vector3DChecker_Type);
    {
        PyObject *tmp_value;
         // ns3::HalfDuplexIdealPhy::IDLE
        tmp_value = PyInt_FromLong(ns3::HalfDuplexIdealPhy::IDLE);
        PyDict_SetItemString((PyObject*) PyNs3HalfDuplexIdealPhy_Type.tp_dict, "IDLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::HalfDuplexIdealPhy::TX
        tmp_value = PyInt_FromLong(ns3::HalfDuplexIdealPhy::TX);
        PyDict_SetItemString((PyObject*) PyNs3HalfDuplexIdealPhy_Type.tp_dict, "TX", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::HalfDuplexIdealPhy::RX
        tmp_value = PyInt_FromLong(ns3::HalfDuplexIdealPhy::RX);
        PyDict_SetItemString((PyObject*) PyNs3HalfDuplexIdealPhy_Type.tp_dict, "RX", tmp_value);
        Py_DECREF(tmp_value);
    }
    {
        PyObject *tmp_value;
         // ns3::AlohaNoackNetDevice::IDLE
        tmp_value = PyInt_FromLong(ns3::AlohaNoackNetDevice::IDLE);
        PyDict_SetItemString((PyObject*) PyNs3AlohaNoackNetDevice_Type.tp_dict, "IDLE", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::AlohaNoackNetDevice::TX
        tmp_value = PyInt_FromLong(ns3::AlohaNoackNetDevice::TX);
        PyDict_SetItemString((PyObject*) PyNs3AlohaNoackNetDevice_Type.tp_dict, "TX", tmp_value);
        Py_DECREF(tmp_value);
         // ns3::AlohaNoackNetDevice::RX
        tmp_value = PyInt_FromLong(ns3::AlohaNoackNetDevice::RX);
        PyDict_SetItemString((PyObject*) PyNs3AlohaNoackNetDevice_Type.tp_dict, "RX", tmp_value);
        Py_DECREF(tmp_value);
    }
    submodule = initspectrum_FatalImpl();
    if (submodule == NULL) {
        return;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "FatalImpl", submodule);
    submodule = initspectrum_addressUtils();
    if (submodule == NULL) {
        return;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "addressUtils", submodule);
}
